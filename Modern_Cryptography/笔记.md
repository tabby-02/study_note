# 第一章.引言

## 1.信息安全的基本属性

 机密性

 可用性

 完整性

 认证

 不可否认性

 访问控制

## 2.凯撒密码

HELLO -> KHOOR(右移三)

移位密码或加法密码

## 3.发展史

### 1.古典密码

时间区域：从由人类以来**到1800年**

 密码设计与分析被当作一门**艺术**

 这一时期的密码学专家常常是凭直觉和信念来进

行密码设计和分析，而不是靠推理证明

 数据的保密**基于加密算法的保密**

### 2.近代密码

时间区域：从1800到1949年

出现密码算法设计的基本手段(代替法 & 置换法)

保密性：数据的保密基于加密算法的保密

### 3.现代密码I阶段

时间跨度：**1949年**-1976年

1949年：

**<u>Shannon</u>**发表“The Communication Theory ofSecret Systems”（SP网络）

定义理论安全性，**提出扩散和混淆原则**

奠定了密码学的**理论基础**

**艺术->科学**

保密性：数据的安全**基于密钥**而不是算法的保密



### 4.现代密码II阶段

时间跨度：**1976年**-1994年

1976年**<u>Diffie& Hellman</u>**的“New Directions inCryptography”提出了**公钥密码的概念**

1977年Rivest, Shamir & Adleman提出了**RSA**公钥算法（**第一个公钥加密算法的提出者**）



### 5.现代密码III阶段

时间区域：**1994年**至未来

1994年，**<u>Shor</u>**提出**量子计算机模型**下分解大整数和求解离散对数的多项式时间算法

## 4.单向函数

f(x)是单向函数，如果它满足：

已知x，计算f(x)是容易的

已知f(x) ，计算x是困难的，即：在计算上是不可行的

不存在函数已经证明 是单向函数

## 5.陷门单向函数

f(x)是陷门单向函数，如果它满足：

已知x，计算f(x)是容易的

已知f(x)，计算x是困难的，即：在计算上是不可行的

**如果知道trapdoor，已知f(x)，计算x是容易的**

例如：RSA加密算法

## 6.一个好的密码体制至少应满足的两个条件

(1) 在已知明文m和加密密钥k1时，计算 c = Ek1(m) 容易，（**加密**）

在已知密文c和解密密钥k2时，计算m = Dk2(c)容易；（**已知密钥时解密**）

(2)在不知解密密钥k2时，不可能由密文c恢复出明文m。（**直接解密**）

## 7.密码算法的分类

按照功能分类

加密算法：用于**机密性**解决方案

杂凑函数：用于**完整性**解决方案

数字签名：用于**认证和不可否认性**

按照密钥的使用方式不同分类

**对称密钥密码**：加密密钥和解密密钥相同（分组密码，流密码）

**非对称密钥密码体制**：加密密钥和解密密钥不同（公钥加密，数字签名）

## 8.密码分析学

### 1.前提

假定密码分析者和敌手知道所使用的密码系统。即密码体制的安全性**仅依赖于对密钥的保密**,而**不应依赖于算法的保密**

### 2.密码体制的攻击

唯密文攻击：仅知道一些**密文**

已知明文攻击：知道一些**明文**和相应的**密文**

选择明文攻击：可以**选择**一些**明文**，并得到相应的**密文**

选择密文攻击：可以**选择**一些**密文**，并得到相应的**明文**(包含选择明文攻击得到的信息)

### 3.无条件安全与计算上安全

**无条件安全的(不可破译的)**：**无论截获多少密文**，都没有足够信息来唯一确定明文，则该密码是无条件安全的，即对算法的破译不比猜测有优势

**计算上安全**的：使用**有效资源**对一个密码系统进行分析而未能破译，则该密码是强的或计算上安全的

### 4.密码算法准则（满足其中之一就可）

（1） 破译密文的**代价**超过被加密信息的**价值**。

（2 ) 破译密文所花的时间超过信息的**有用期**。

## 9.古典密码体制

### 1.置换密码（易位密码）

字或字母本身不变，但**位置发生了改变**，形成密文

### 2.代换密码（代替密码）

把明文中的每一个字符**替换**成密文字母表中的另一个字符

#### (1).单表代替密码

加法密码：y=x+k（mod26)     //凯撒密码

乘法密码：y=kx(mod26)  ，条件：(k,26)=1

仿射密码：y=ax+b(mod26)  ，条件：(k,26)=1，解密：x=(y-b)a^-1 mod 26（**关键计算a^-1,利用扩展欧几里得算法**）

密钥短语代替密码：选个短语，去掉其中的重复字母，而后再将字母表中未在字母串中出现过的字母依次写于此短语之后，就可以构造一个字母替换表

#### (2).Vigenere密码（分组代换）

定义密钥k=(k1,k2,k3...km),E=(x1+k1,x2+k2,......xm+km)   mod26

方法：分组，**每组长m**，按照k加密

#### (3).多表代换密码（分组二维仿射加密）

<img src="\Snipaste_2024-05-25_10-26-57.png" style="zoom:60%;" /> 

# 第二章.分组密码

## 1.概述

![](\Snipaste_2024-05-25_10-56-46.png) 

通常取n=m。

• 若n<m ，则为有数据扩展的分组密码。

• 若n>m ，则为有数据压缩的分组密码。

分组密码算法应满足的要求

1）**分组长度**n要足够大

2）**密钥量**要足够大

3）由密钥确定**置换的算法**要足够复杂

## 2.安全性设计原则

### 1.混淆原则

混淆原则就是将密文、明文、密钥三者之间的**统计关系**和**代数关系**变得尽可能复杂，使得敌手即使获得了密文和明文，也无法求出密钥的任何信息；即使获得了密文和明文的统计规律，也无法求出明文的新的信息。

### 2.扩散原则

让**明文**中的每一位**影响密文中的尽可能多的位**，或者说让密文中的每一位都受到明文中的尽可能多位的影响

## 3.SP网络（代换置换网络）

代换是输入集A到输出A’上的双射变换：

fk：A->A＇

实现代换fk的网络称作代换网络

### 代换盒(S盒)

在密码设计中，可选**n=r*n0**，其中r和n0都为正整数，将设计**n个变量**的代换网络化为设计r个较小的子代换网络，而每个**子代换网络只有n0个输入变量**。称每个子代换网络为代换盒

## 4.Feistel密码（乘积密码）

定义：乘积密码指**顺序地执行两个或多个基本密码系统**，使得最后结果的密码强度高于每个基本密码系统产生的结果

算法：输入是分组长为2w的明文和一个密钥K。将每组明文分成左右两半L0和R0，在进行完n轮迭代后，左右两半再合并到一起以产生密文分组。第i轮迭代的输入为前一轮输出的函数：

左：**Li = Ri-1**

右：**Ri =Li-1 ⊕ F(Ri-1,Ki)**

<img src="\Snipaste_2024-05-25_11-25-27.png" style="zoom:80%;" /> 

## 5.DES--64，56

• 分组长度为**<u>64 bits</u>** (8 bytes)

• 密文分组长度也是64 bits。

• 密钥长度为64 bits，有**8 bits奇偶校验**，有效密钥长度为**<u>56 bits</u>**。

• 算法主要包括：初始置换IP、16轮迭代的乘积变换、逆初始置换IP^-1以及16个子密钥产生器

<img src="\Snipaste_2024-05-25_11-43-10.png" style="zoom:80%;" /> ![](\Snipaste_2024-05-25_12-25-44.png) 

### 1.IP置换（64-64）

IP和IP-1在密码意义上作用不大，它们的作用在于**打乱原来输入x的ASCII码<u>字划分</u>的关系**。

<img src="\Snipaste_2024-05-25_11-49-37.png" style="zoom:60%;" /> 

### 2.轮函数

设输入为（x，y），轮函数输出为（y, x ⊕fk(y)）

它等价于两个对合变换的复合: (x,y) ↦ (x⊕f(k,y),y) ↦ (y,x⊕f(k,y))

<img src="\Snipaste_2024-05-25_11-59-00.png" style="zoom:80%;" /> 

### 3.S盒结构（48-32）

<img src="\Snipaste_2024-05-25_12-03-45.png" style="zoom:60%;" /> 

### 4.移位次数表（密钥生成的循环移位中）

<img src="\Snipaste_2024-05-25_12-38-34.png" style="zoom:100%;" /> 

### 5.填充（指示符PI）

给定加密消息的长度是随机的，按64 bit分组时，**最后一组消息长度可能不足64 bit**。可以填充一些数字，通常用**最后1字节作为填充指示符（PI）**。它所表示的十进制数字就是**填充占有的字节数**。

<img src="\Snipaste_2024-05-25_12-40-50.png" style="zoom:60%;" /> 

### 6.安全性

#### • 互补性

DES算法具有下述性质。若明文组x逐位取补，密钥k逐位取补，即y=DESk(x), 则有y补=DESk补(x补)这种互补性会使DES在选择明文破译下所需的工作量**减半**。

#### • 弱密钥

如果给定初始密钥k，**各轮的子密钥都相同**，即有k1=k2= … =k16，就称给定密钥k为**弱密钥**

• 弱密钥: EK*EK = I ，DES存在4个弱密钥

DESk(DESk(x))=x

• 半弱密钥: EK1 = EK2 ，至少有12个半弱密钥

y=Ek1(x)=Ek2(x)

#### • 攻击手段

**穷举密钥搜索攻击**（1997破解）

DES的其他攻击方法：

时间-空间权衡攻击、差分攻击、线性攻击和相关密钥攻击等方法，

在这些攻击方法中，线性攻击方法是最有效的一种方法

## 6.多重DES

大大提高**抵抗穷举密钥搜索攻击**的能力

### 1.双重DES的中间相遇攻击

已知明密文对(x1,y1),双重DES加密E-->-->D

1.以密钥**k1的所有**2^56个**可能的取值**对此明文x1**加密**

2.从**所有可能**的2^56个密钥**k2**中依任意次序选出一个对给定的密文y1**解密**，并将每次解密结果z在上述表中**查找**相匹配的值。一旦找到，则可确定出两个密钥k1和k2；

3.以此对密钥k1和k2对**另一已知明文密文对**(x2, y2)中的明文x2进行加密，如果能得出相应的密文y2就可确定k1和k2是所要找的密钥

密钥搜索量：<u>2*2^56</u>

可能的密钥数为2^112个。所以，在给定明文下，将有2^112/2^64 =2^48个密钥能产生给定的密文。?????????

### 2.三重DES

三重DES中三个密码组件**既可以是一个加密函数，也可以是一个解密函数**

#### 双密钥三重DES（EDE）

当**k1=k3**时，则称为双密钥三重DES

加密：y=Ek1[Dk2[Ek1 [x]]]

称其为**加密-解密-加密方案**，简记为EDE

密钥搜索量：<u>2^112</u>

## 7.分组密码的工作模式

**分组密码的工作模式**是：根据不同的数据格式和安全性要求, 以一个**具体的分组密码算法**（例DES）为基础**构造**一个**分组密码<u>系统</u>**的方法

• 需要采用适当的工作模式来隐蔽明文的<u>统计特性</u>、<u>数据的格式</u>等

### 1.电码本模式（ECB）

相同**明文分组**对应相同**密文分组**

特点：**不能隐蔽**明文分组的**统计规律**和结构规律,不能抵抗替换攻击

<img src="\Snipaste_2024-05-25_14-00-02.png" style="zoom:60%;" /> 

### 2.密码分组链接模式(CBC)--对异或的明文加密

先将明文分组与**上一次的密文块**进行按比特**异或**，然后再进行加密.

必须选择一个初始向量c0=IV，用于加密第一块明文

ci=Ek(mi⊕ci-1)

特点：明文块的**统计特性得到了隐蔽**

具有有限的(**两步**)**错误传播**特性

具有**自同步**功能（若从第t块起密文块正确,则第t+1个明文块就能正确求出）

<img src="\Snipaste_2024-05-25_14-00-10.png" style="zoom:60%;" /> 

### 3.密码反馈模式(CFB)--对Ij加密，明文异或

适用于**每次处理 r比特明文块**的**特定需求**的加密情形,能灵活适应数据各格式的需要

将上一次加密的结果放入Ij再左移，将Ij加密后取最左边的r项

必须选择一个初始向量IV=c-L+1…c-1 c0， |ci|=r，则加密过程可表示为:ci=xi⊕leftr(E(ci-L....ci-2ci-1))

特点：相同明文（改变IV同样会导致相同的明文输入得到不同的加密输出）

链接依赖性

错误的传播

错误恢复(自同步)

<img src="\Snipaste_2024-05-25_14-33-05.png" style="zoom:60%;" /> 

### 4.输出反馈模式(OFB)--对Ij加密，明文异或

结构上类似于CFB模式，但**反馈的内容**是**DES的输出**而不是密文

<img src="\Snipaste_2024-05-25_14-40-57.png" style="zoom:60%;" /> 

### 5.计数器模式(CTR)--对自然数加密，明文异或

特点：可以产生**伪随机数**序列

可**并行**加密

加密数据块的**随机访问**

<img src="\Snipaste_2024-05-25_14-43-16.png" style="zoom:60%;" /> 

### 应用

#### 利用CBC模式实现报文的完整性认证

n个明文分组m=(m1,....,mn),**校验码**为r=mn+1=m1⊕....⊕mn,**认证码**为Cn+1=r加密后对应项

(1) 仅需对明文认证,而不需加密时,传送明文m和认证码Cn+1，此时也可仅保留Cn+1的 t 个比特作为认证码；

(2) 既需对明文认证,又需要加密时,传送密文C和认证码Cn+1

对应(1),**验证者**接收到明文(校验码)和认证码，需要对(m,r)**加密**，将得到的最后一个密文分组与认证码Cn+1比较

对应(2),**验证者**接收到密文(认证码)，需要对密文进行**解密**，得到明文和校验码，再进行验证操作

## 8.域

### 1.域

对于任一不可约多项式f(x)，F[x]/(f(x))为域

F[x]/(f(x))={r(x)=rn-1*x^n-1+rn-2*x^n-2+…+r1*x+r0|ri∈F, 0≤i≤n-1}

AES将每一字节(8位)看作是有限域GF(2^8)上的一个元素,也可表示为一个两位的十六进制数

01101011，    b7x^7+b6x^6+b5x^5+b4x^4+b3x^3+b2x^2+b1x^1+b0,       6B

### 2.GF(2^8)中的运算

加法：和的系数模2

乘法：乘积模一个次数为8的不可约二进制多项式

### 3.乘法简便运算**xtime(x)**

函数xtime(x)定义为GF(2)上的x·b(x)=b7x^8+b6x^7+b5x^6+b4x^5+b3x^4+b2x^3+b1x^2+b0x mod m(x)

若b7 =0，则x·b(x)的结果就是把字节b左移一位，且在最右边补上上0；

若b7 =1，则先对b(x)在字节内左移一位（最后一位补0），则再与‘1B’（00011011）做逐比特异或。

x-->02,即x·b(x)='02'·b(x),同理可以快速算出'04'·b(x)='02'·'02'·b(x),最后要求的y·b(x)中y用01,02,04等加得，再展开计算

### 4.多项式可逆

系数在GF(2^8)上的**多项式**a3x^3+a2x^2+a1x+a0是模x^4+1**可逆**的，**当且仅当**矩阵

**a0  a3  a2  a1**

**a1  a0  a3  a2**

**a2  a1  a0  a3**

**a3  a2  a1  a0**

在GF(2^8)上**可逆**

## 9.AES（Rijndael）--128，128/192/256

没有采用Feistel结构，轮函数由3个不同的**可逆均匀变换**构成的，称为**3个层**(均匀变换是指状态的每个bit都用类似的方法处理)

• **线性混合层**

确保多轮之上的高度**扩散**；

• **非线性层**

将具有最优的“最坏情况非线性特性”的S盒并行使用，确保**混淆**特性；

• **密钥加层**

单轮子密钥简单的异或到中间状态上，实现**一次性掩盖**

<img src="\Snipaste_2024-05-25_16-00-58.png" style="zoom:80%;" /> 

AES明文**分组固定为128比特**

**状态**(中间结果)：列数**Nb**为分组长度除32，行数为4（一列有32位，32位正好表示成一个四次多项式，每个系数一字节，即系数模64，也可以说是系数是两位的16进制数）(表中一个元素即为一个系数，也是一个字节)

**种子密钥**：列数**Nk**为密钥长度除32，行数为4

**轮数**：**Nr**<img src="\Snipaste_2024-05-25_16-17-20.png" style="zoom:60%;" /> 



### 1.字节代换   ByteSub

**S盒设计**：y=Ax^-1+B(S盒输入最大为ff，即64，即8比特，即1字节)

对状态的**每个字节**进行两步

(1) 将字节作为GF(2^8)上的元素**映射到自己的逆元**'模x^4+1'

(2) 将字节做GF(2)上的仿射变换,即**y=Ax^-1+B**(A为8*8矩阵，B为列向量)

<img src="\Snipaste_2024-05-25_16-10-16.png" style="zoom:60%;" /> 

逆字节变换：x=(A^-1(y-B))^-1

### 2.行移位  ShiftRow

各行进行循环**左移**，不同行的移位量不同<img src="\Snipaste_2024-05-25_16-17-08.png" style="zoom:60%;" /> 
0行：不动

1行：循环左移C1**字节**

2行：循环左移C2字节

3行：循环左移C3字节

逆行移位：改为循环**右移**，行数对应移动字节数和前面一样

### 3.列混淆   MixColumn

将**每列**（4字节）视为GF(2^8)上多项式，**与固定的多项式<u>c(x)</u>进行模x^4+1乘法**（系数为模64，即两位的16进制数），记为⊗ ,要求c(x)模x^4+1可逆

例：系数运算 '03'+'02'+'11'='16'

逆列混淆：将状态矩阵中的**每列**视为系数在GF(2^8)上的次数小于4的多项式**与同一个固定的多项式 <u>d(x)</u>相乘**，d(x)满足<u>d(x)</u>⊗<u>c(x)</u>='01'

### 4.轮密钥加   AddRoundKey

**轮密钥**与**状态**进行逐比特**异或**

### 5.密钥编排

指从种子密钥得到轮密钥的过程，它由密钥扩展和轮密钥选取两部分组成

• （1）**轮密钥的总比特数**(**扩展密钥比特数**)等于分组长度乘以(轮数加1)；例如要将128比特的明文经过10轮的加密，则总共需要（10+1）																																												·128=1408比特的密钥。

•（2）扩展：**种子密钥(128/192/256)**被扩展成为**扩展密钥(128·(Nr+1))**；

•（3）选取：**轮密钥**(128)从扩展密钥中取，其中第1轮轮密钥取扩展密钥的前(128)个字，第2轮轮密钥取接下来的(128)个字，如此下去

## 10.SM4--128，128

分组长度和密钥长度均为128比特，共32轮

轮函数：**Xi+4=Xi⊕T(Xi+1⊕Xi+2⊕Xi+3⊕rki)**---第i-1轮

(K0,K1,K2,K3)=(MK0⊕FK0,MK1⊕FK1,MK2⊕FK2,MK3⊕FK3)----加密密钥MK=(MK0,MK1,MK2,MK3)=128

轮密钥：**rki=Ki+4=Ki⊕T'(Ki+1⊕Ki+2⊕Ki+3⊕CKi)**---32位

S盒设计：y=A(Ax+B)^-1+B(比AES的S盒设计多了一个仿射变换)

<img src="\Snipaste_2024-05-25_18-04-15.png" style="zoom:80%;" /> 

<img src="\Snipaste_2024-05-25_18-04-24.png" style="zoom:80%;" /> 轮函数

<img src="\Snipaste_2024-05-25_18-22-16.png" style="zoom:60%;" /> 轮密钥

# 第三章.序列密码

## 1.流密码(序列密码)

### 1）一次一密密码

密钥仅用一次的单表代替密码的**加法密码**

• 优点：

**密钥随机产生**，仅使用一次

**无条件安全**

加密和解密为加法运算，效率较高

• 缺点：

**密钥长度至少与明文长度一样长**，密钥共享困难，不太实用

### 2）流密码定义

流密码主要是**基于硬件**实现

利用**密钥k**产生一个**密钥流**z=z0z1z2…，并使用如下规则对明文串x=x0x1x2…加密：

y=y0y1y2…＝E0(x0)E1(x1) E2(x2)…，（Ei(xi)=Ezi(xi),即在zi条件下的加密E）

zi＝f(k,σi)   ---σi是加密器中的记忆元件在时刻 i 的状态

内部记忆元件由一组移位寄存器构成

### 3）同步流密码

内部记忆元件的**状态σi独立于明文字符**的叫做**同步流密码**，否则叫做自同步流密码

### 4）加法流密码

<img src="\Snipaste_2024-05-26_09-17-24.png" style="zoom:60%;" /> 

yi=zi⊕xi

一次一密密码是加法流密码的原型，如果密钥用作滚动密钥流，则加法流密码就**退化成一次一密密码**

### 5）密钥流序列应具有的性质

Ø **极大的周期**

Ø 良好的**统计特性**

Ø **抗线性分析**

## 2.二元序列的伪随机性

### 1）二元序列

定义：**GF(2)上**的一个无限序列a=(a1,a2....an,....)称为二元序列，若ai属于GF(2) 。

周期L/p(a)：L是满足对于一切正整数k都有ak=ak+L的**最小正整数**

游程：**一个周期**的数**排成圆周**，相邻的1称为1的游程，1的个数为1游程的长度，0亦然。

#### 自相关函数：

<img src="\Snipaste_2024-05-26_09-30-56.png" style="zoom:60%;" /> 

### 2）伪随机序列

#### 1.Golomb伪随机公设：

① 在序列的一个周期内，0与1的个数**相差至多为1**。(0,1出现概率相同)

② 在序列的一个周期内，**长为i的游程**占游程总数的**1/2^i**(i=1,2,…)，且在**等长的游程**中0的游程个数和1的游程**个数相等**。（0，1每一位置出现概率相同）（长1->1/2,长2->1/4）

③ **异相自相关函数**是一个**常数**。（对序列与其平移后的序列做比较，不能给出其他任何信息）

#### 2.伪随机序列定义

二元序列a，对一切    t=/=0(modp(a)),      有**R(t)=-1**,则a为伪随机序列

#### 3.伪随机序列还应满足的条件

周期p要足够大

序列易于高速生成

不可预测性：序列任何部分暴露，分析整个序列不可行

## 3.线性反馈移位寄存器

### 1）反馈移位寄存器   FSR

一个n级反馈移位寄存器由**n个二元存储器**与一个**反馈函数**f(a1,a2,…,an)组成-----------------(f为**布尔函数**：函数的自变量和因变量只取0和1)

<img src="\Snipaste_2024-05-26_09-48-49.png" style="zoom:60%;" /> 状态：(a1,a2,…,an)

### 2）线性反馈移位寄存器  LFSR

反馈函数**f(a1,a2...an)=c1an⊕c2an-1......cna1**

**结构常数**为[c1,c2,.....cn]

<img src="\Snipaste_2024-05-26_09-52-35.png" style="zoom:60%;" /> 

总是假定c1,c2,…,cn中至少有一个不为0，否则f(a1,a2,…,an)≡0。总是**假定cn=1**。（即总是有a1）

LFSR输出序列的性质：完全由其反馈函数决定。

n级LFSR的状态周期： <= 2^n-1(状态共2^n种)

输出序列的周期=状态周期，<=2^n   -1

使序列的**周期达到最大值2^n-1的序列称为m序列**

## 3+.m-序列（特殊的LFSR：周期达到最大值2^n   -1）

LFSR的**特征多项式p(x)**：<img src="\Snipaste_2024-05-26_10-25-24.png" style="zoom:60%;" /> （反馈函数第i项为p(x)的第i+1项）

序列的**生成函数A(x)**：幂级数<img src="\Snipaste_2024-05-26_10-25-10.png" style="zoom:60%;" /> 

**G(p(x))**:p(x)的的非零全体可能值(2^n   -1个)

定理：A(x)满足条件：<img src="\Snipaste_2024-05-26_10-28-11.png" style="zoom:60%;" /> <img src="\Snipaste_2024-05-26_10-28-16.png" style="zoom:60%;" /> ai为初始状态，即φ(x)由初始状态决定

**p(x)的阶/周期**：使p(x)|(x^p  -1)成立的最小正整数p（p(x)的阶总是大于等于p(x)的次数）（p(x)次数为n，周期为p）

定理：p(x)|q(x)的充要条件是G(p(x))被包含于G(q(x)---说明：可用n级LFSR产生的序列，也可用级数更多的LFSR来产生

定理：若序列{ai}的特征多项式p(x)定义在GF(2)上，p是p(x)的周期，则{ai}的周期r|p---说明：n级LFSR输出序列的周期r，不依赖于初始条                      																																										件，而依赖于特征多项式p(x)

定理：设p(x)是n次不可约多项式，周期为m，序列{ai}∈G(p(x))，则{ai}的周期为m。

定理：n级LFSR产生的序列有最大周期2^n  -1的必要条件是其特征多项式为不可约的

**本原多项式**：若n次**<u>*不可约*</u>**多项式p(x)的**<u>*阶为2^n  -1*</u>**，则称p(x)是n次本原多项式

定理：设{ai}∈G(p(x))，{ai}为m序列的充要条件是p(x)为本原多项式（**<u>*m序列<=>p(x)是本原多项式*</u>**）

### m-序列的安全性

输出序列即为密钥流，可以由明文和密文异或得到（明文+密文->密钥流->序列->递推式）

#### 1.解方程法

已知序列{ai}是由n级线性移存器产生的，并且知道{ai}的**连续2n位**，可用解线性方程组的方法得到反馈多项式

设出线性递推式，再将序列带入得方程组求解ci

<img src="\Snipaste_2024-05-26_11-29-56.png" style="zoom:60%;" /> 

#### 2.Berlekamp-Massey算法（B-M算法）

**线性综合解**：<f(x),L>    ----f(x)为特征多项式，L为级数

1.取初始值：<img src="\Snipaste_2024-05-26_11-43-08.png" style="zoom:60%;" />                注： <img src="\Snipaste_2024-05-26_11-47-33.png" style="zoom:60%;" /> 

2.计算dn步差值<img src="\Snipaste_2024-05-26_11-42-01.png" style="zoom:60%;" /> 

(i)若dn=0,令<img src="\Snipaste_2024-05-26_11-42-59.png" style="zoom:60%;" />

(ii)若dn=1,<img src="\Snipaste_2024-05-26_11-44-01.png" style="zoom:60%;" /> 

​	

<img src="\Snipaste_2024-05-26_11-39-58.png" style="zoom:80%;" /> 

## 4.非线性序列

### 1）密钥流生成器

密钥流生成器可分解为驱动子系统和非线性组合子系统<img src="\Snipaste_2024-05-26_12-24-43.png" style="zoom:60%;" /> 
• **驱动子系统**常用一个或多个**线性反馈移位寄存器**来实现

• **非线性组合子系统**用**非线性组合函数F**来实现

### 2）Geffe序列生成器（含3个LFSR）

Geffe序列生成器由**3个LFSR**组成

• 当LFSR2输出1时，LFSR2与LFSR1相连接

• 当LFSR2输出0时，LFSR2与LFSR3相连接

LFSRi的特征多项式分别为ni次**本原多项式**（**m序列**），且**ni 两两互素**

 <img src="\Snipaste_2024-05-26_13-29-00.png" style="zoom:80%;" /><img src="\Snipaste_2024-05-26_13-27-12.png" style="zoom:80%;" /> =n1n2+n3(1-n2)=n1n2+n3+n2n3=(n1+n3)n2+n3

<img src="\Snipaste_2024-05-26_13-27-41.png" style="zoom:60%;" /> <img src="\Snipaste_2024-05-26_13-27-49.png" style="zoom:60%;" /> =bk

（三个m序列相乘）

### 3）J-K触发器（含0个LFSR）

J-K触发器输入端一般为**2个LFSR**

<img src="\Snipaste_2024-05-26_13-42-28.png" style="zoom:60%;" /> <img src="\Snipaste_2024-05-26_13-42-35.png" style="zoom:80%;" /> ⥄等同于 · ，即乘法

<img src="\Snipaste_2024-05-26_13-42-56.png" style="zoom:80%;" /> 

​																					（两个m序列相乘）

**JK弱点：**如果知道{ck}中相邻位的值ck-1和ck，就可以推断出ak和bk中的一个。就可通过密码分析的方法得到序列{ak}和{bk}

故设计<u>Pless生成器</u>克服<u>利用J-K触发器的非线性序列生成器</u>的弱点

### 4）Pless生成器（含8个LFSR）

Pless生成器由**8个LFSR**、**4个J-K触发器**和**1个循环计数器**构成

<img src="\Snipaste_2024-05-26_13-50-33.png" style="zoom:80%;" /> 

### 5）钟控序列生成器（含2个LFSR）

是用一个LFSR控制另外一个LFSR的移位时钟脉冲

•当**LFSR1输出1**时，移位时钟脉冲通过与门使LFSR2**进行一次移位**，从而**生成下一位**。

• 当**LFSR1输出0**时，移位时钟脉冲无法通过与门影响LFSR2。因此LFSR2**重复输出前一位**。

<img src="\Snipaste_2024-05-26_13-59-17.png" style="zoom:80%;" /> 

• 若{ak}和{bk}的极小特征多项式分别为GF(2)上的m和n次<u>**本原多项式**</u>f1(x)和f2(x)，且**<u>m|n</u>**，则<img src="\Snipaste_2024-05-26_14-07-02.png" style="zoom:100%;" /> 

<img src="\Snipaste_2024-05-26_14-15-41.png" style="zoom:60%;" /> （将f2(x）中的x替换为x^(2^m   -1))

<img src="\Snipaste_2024-05-26_14-25-57.png" style="zoom:60%;" /> 特征多项式(n+1项)第一项不用,反馈函数(n项)都用

<img src="\Snipaste_2024-05-26_14-26-04.png" style="zoom:60%;" /> 

<img src="\Snipaste_2024-05-26_14-40-20.png" style="zoom:60%;" /> 

# 第四章.公钥密码

## 1.公钥密码体制（非对称密码体制）

### 概念：

• 每个用户生成一个密钥对：一个公钥pk和一个对应的私钥 sk

• 公钥将在系统内被公开

• 私钥由用户本人安全保管

### 公钥密码的主要作用

• 公钥加密

任何人可以用**公钥加密**消息，**私钥**的拥有者可以**解密**消息

• 数字签名 (Digital Signature) 

**私钥**的拥有者**生成数字签名**，任何人可以用**公钥验证签名**

• 基于公钥的密钥分配(Key Distribution)

### 公钥密码体制的优势

• 密钥分发：公钥能够采用**公开**（认证的）信道进行**传输**；

• 密钥管理：在用户N个用户的系统中，每个用户只需安全保管自己的**私钥**和**N-1个**其他用户的**公钥**。整个系统仅仅需要**维护N个公钥**；（对称密码要N(N-1)/2）

• 开放系统：即使是**没有预先建立关系**的用户也能通过对方的公钥建立安全通信。

### 公钥密码的理论基础: **陷门单向函数**

## 2.计算复杂性

算法的计算时间和存储空间（分别称为算法的**时间复杂度**和**空间复杂度**）定义为算法输入数据的长度 n 的函数f(n)

若算法的时间复杂度为**T=O(n^k)** ，则称该算法是**多项式时间**的；（T=O(n^5)）

若**T=O(k^f(n))**，其中k是常数， f(n)是多项式，就称该算法是**指数时间**的。（T=O(2^n)）

## 3.P和NP问题

**P问题**是指可以在多项式时间内判定的语言集合(**求解)**

**NP问题**是指可在多项式时间内验证它的一个解的问题。(**验证**)

因为求解(P)比验证(NP)更困难，故P∈NP

## 4.几个困难问题

大整数分解问题:n=pq，求n容易，求p，q困难

离散对数问题:y=g^x(modp)，求y容易，求x困难

多项式求根问题:多项式，求y容易，求x困难

二次剩余问题:x^2≡a(modn)，n分解未知时求x困难

背包问题:A= (ai),x=(xi),s=a1x1+...anxn，求s容易，求x困难

MQ问题:求解有限域上任意选取的多变量二次多项式方程组问题

<img src="\Snipaste_2024-05-26_15-57-58.png" style="zoom:60%;" /> 

<img src="\Snipaste_2024-05-26_15-57-47.png" style="zoom:60%;" /> 利用函数f构造签名

<img src="\Snipaste_2024-05-26_15-58-56.png" style="zoom:60%;" /> 

## 5.RSA

### 1）原理

• 选取两互异大素数p和q

• 计算 n=p×q 和其欧拉函数值φ(n)=(p－1)(q－1)

• 选一整数e，1 < e<φ(n)，使得 gcd(φ(n), e)=1

• 在模φ(n)下，计算e的逆元d. 即求d, 使得ed ≡ 1 mod (n)

• 以(n，e )为公钥。d 为秘密钥。

将明文分组，分组大小小于n

加密 c =E(m)≡ m^e mod n

解密 m = D(c)≡ c^d mod n

RSA解密正确性证明：1.m，n互素-欧拉定理-c^d^=m^kφ(n)+1^=m modn

2.不互素-设m=xp,m^φ(q)=1 modq->m^φ(n)=1 modq->m^φ(n)^=1+rq->m^φ(n)+1^=m+rxpq->m^φ(n)+1^=m+rxn=m modn

### 2）计算

#### 1.模整数幂

(a×b) mod n=[(a mod n)×(b mod n)] mod n               **先乘再模->先模再乘**

#### 2.快速指数算法

<img src="\Snipaste_2024-05-26_16-43-08.png" style="zoom:80%;" /> 

#### 3.Miller-Rabin算法（概率素性检测）

引理：如果p为大于2的素数，则方程x^2≡1(mod p)的解只有x≡1和x≡-1。

引理的逆否命题为：如果方程x^2≡1 mod p有一解x0 {-1,1}，那么p不为素数

(Fermat)若p是素数，a是正整数且gcd(a, p)=1，则a^p-1≡1 mod p

<img src="\Snipaste_2024-05-26_16-58-22.png" style="zoom:80%;" /> 

只要有一次算法返回为False，就可肯定n不是素数。

如果算法每次返回都为True，则n是素数的概率至少为1-4^-s

### 3）RSA安全性

模数长度应该介于1024bit到2048bit之间

确定φ(n)等价于分解了n

#### 对p和q 提出以下要求

（1） p - q 要大:如果|p-q|小,则(p+q)/2稍大于n^0.5,则可在n^0.5附件找到整数x使x^2-n=y^2(y是整数),即n=(x+y)(x-y)

（2）p -1和 q -1 都应有大素因子:设攻击者截获密文 c ，可进行重复加密,直到c^(e^t)=c,即m^(e^(t+1))=m^e,即m^(e^t)=m,即得到m

#### 对RSA的攻击

1.共模攻击:如果两次加密(公钥e1,e2)的m相同，且e1,e2互素，可用扩展欧几里得恢复m--找到r,s使re^1+se^2=1,构造m^(re^1+se^2)

2.低指数攻击：如果每个用户的加密指数都很小,且m相同，可用中国剩余定理恢复m

3.选择密文攻击---->RSA是确定性的加密算法, 不能抵御选择密文攻击：攻击者已知c1,构造c2=c1m2^e给挑战者解密得m2'，

m2'=c1^d*m2=m1*m2,故m1=m2'*m2^-1

## 6.ElGamal密码体制

### 1）Diffie-Hellman密钥交换

基于求**离散对数的困难性**

<img src="\Snipaste_2024-05-26_18-37-11.png" style="zoom:60%;" /> 

### 2）ElGamal密码体制

#### 1.原理

1. 密钥产生过程： 选择一素数p以及小于p的随机数x， g是p的原根,计算y≡g^x mod p。

  **(y, g, p)**作为公开密钥，**x**作为秘密密钥。

2. 加密过程： 明文消息M，随机选一整数 k<p-1，计算

  **C1≡g^k** （mod p）, **C2≡y^k*M** （mod p）

  密文为**C=(C1,C2)**。

3. 解密过程：

  **M=c2(c1^x)^-1** (mod p)

#### 2.特点

1. 安全性基于有限域上的**离散对数**的难解性
2. 加密算法是**概率算法**
3. **不能**抵御**选择密文**攻击（作业）
4. 存在**密文扩张**

#### 3.参数要求

• p应为**150位以上十进制数**，500位以上的二进制数，**p-1应有大素数因子**。

• **K**必须保密而且必须是**一次性**的。

## 7.椭圆曲线密码体制 ECC（了解）

### 1）椭圆曲线

#### 常用方程

y^2≡x^3+ax+b(mod p)    （p为一大素数）(a,b∈GF(p),4a3+27b2≠0(modp))

#### 加法

① P+O=P。

② 如果P=(x,y)，那么(x, y)+(x, -y)=O   （曲线关于x轴对称）

③ 设P=(x1,y1)，Q=(x2,y2)，P≠-Q（斜率存在），则P+Q=(x3,y3)由以下规则确定：

<img src="\Snipaste_2024-05-26_18-43-45.png" style="zoom:80%;" /> 

#### 困难问题

P∈Ep(a,b), **P的阶是一个非常大的素数**，(P的阶是满足nP=O的最小正整数n，阶即指加法的最小循环周期)

Q=kP，(即k个p点相加)

(1) 已知k和P易**求Q**;

(2) 已知P、Q**求k**则是**困难**的 

### 2）椭圆曲线实现ElGamal密码体制

<img src="\Snipaste_2024-05-26_18-52-32.png" style="zoom:80%;" /> 

#### 原理

p>3大素数，生成元G的阶足够大，取随机整数d,(1<=d<=ord(G)-1)--随机整数k,(1<=k<=ord(G)-1)  

Q=dG							   y=g^x modp

明文Pm							明文M

密文C={kG,Pm+kQ}        C=(g^k,y^k*M)     指变乘，乘变加

解密Pm=Pm+kQ-dkG	   解密M=c2(c1^x)^-1     -1次变减

公钥：Q,G,E					y,g,p

私钥：d							x

#### 明文消息嵌入到椭圆曲线上

设明文消息为m, k是一个足够大的整数(例如30)

计算x={mk+j,j=0,1,2....29}

直到x^3+ax+b(modp)有平方根，则得到点Pm的分量x

解点只需m=x/30(向下取整)

#### 椭圆曲线密码体制的优点

1) 安全性高

2) 密钥量小

3) 灵活性好