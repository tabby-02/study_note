# 第一章.引言

## 1.信息安全的基本属性

 机密性
 可用性
 完整性
 认证
 不可否认性
 访问控制

## 2.凯撒密码

HELLO -> KHOOR(右移三)

移位密码或加法密码

## 3.发展史

### 1.古典密码

时间区域：从由人类以来**到1800年**

 密码设计与分析被当作一门**艺术**

 这一时期的密码学专家常常是凭直觉和信念来进行密码设计和分析，而不是靠推理证明

 数据的保密**基于加密算法的保密**

### 2.近代密码

时间区域：从1800到1949年

出现密码算法设计的基本手段(代替法 & 置换法)

保密性：数据的保密基于加密算法的保密

### 3.现代密码I阶段

时间跨度：**1949年**-1976年

1949年：
Shannon发表“The Communication Theory ofSecret Systems”（SP网络）

定义理论安全性，提出扩散和混淆原则，
奠定了密码学的理论基础

**艺术->科学**

保密性：数据的安全**基于密钥**而不是算法的保密



### 4.现代密码II阶段

时间跨度：**1976年**-1994年

1976年**<u>Diffie& Hellman</u>**的“New Directions inCryptography”提出了**公钥密码的概念**

1977年Rivest, Shamir & Adleman提出了**RSA**公钥算法（**第一个公钥加密算法的提出者**）



### 5.现代密码III阶段

时间区域：**1994年**至未来

1994年，**<u>Shor</u>**提出**量子计算机模型**下分解大整数和求解离散对数的多项式时间算法

## 4.单向函数

f(x)是单向函数，如果它满足：

已知x，计算f(x)是容易的

已知f(x) ，计算x是困难的，即：在计算上是不可行的

不存在函数已经证明 是单向函数

## 5.陷门单向函数

f(x)是陷门单向函数，如果它满足：

已知x，计算f(x)是容易的

已知f(x)，计算x是困难的，即：在计算上是不可行的

**如果知道trapdoor，已知f(x)，计算x是容易的**

例如：RSA加密算法

## 6.一个好的密码体制至少应满足的两个条件

(1) 在已知明文m和加密密钥k1时，计算 c = Ek1(m) 容易，（**加密**）

在已知密文c和解密密钥k2时，计算m = Dk2(c)容易；（**已知密钥时解密**）

(2)在不知解密密钥k2时，不可能由密文c恢复出明文m。（**直接解密**）

## 7.密码算法的分类

按照功能分类

加密算法：用于**机密性**解决方案

杂凑函数：用于**完整性**解决方案

数字签名：用于**认证和不可否认性**

按照密钥的使用方式不同分类

**对称密钥密码**：加密密钥和解密密钥相同（分组密码，流密码）

**非对称密钥密码体制**：加密密钥和解密密钥不同（公钥加密，数字签名）

## 8.密码分析学

### 1.前提

假定密码分析者和敌手知道所使用的密码系统。即密码体制的安全性**仅依赖于对密钥的保密**,而**不应依赖于算法的保密**

### 2.密码体制的攻击

唯密文攻击：仅知道一些**密文**

已知明文攻击：知道一些**明文**和相应的**密文**

选择明文攻击：可以**选择**一些**明文**，并得到相应的**密文**

选择密文攻击：可以**选择**一些**密文**，并得到相应的**明文**(包含选择明文攻击得到的信息)

### 3.无条件安全与计算上安全

**无条件安全的(不可破译的)**：**无论截获多少密文**，都没有足够信息来唯一确定明文，则该密码是无条件安全的，即对算法的破译不比猜测有优势

**计算上安全**的：使用**有效资源**对一个密码系统进行分析而未能破译，则该密码是强的或计算上安全的

### 4.密码算法准则（满足其中之一就可）

（1） 破译密文的**代价**超过被加密信息的**价值**。

（2 ) 破译密文所花的时间超过信息的**有用期**。

## 9.古典密码体制

### 1.置换密码（易位密码）

字或字母本身不变，但**位置发生了改变**，形成密文

### 2.代换密码（代替密码）

把明文中的每一个字符**替换**成密文字母表中的另一个字符

#### (1).单表代替密码

加法密码：y=x+k（mod26)     //凯撒密码

乘法密码：y=kx(mod26)  ，条件：(k,26)=1

仿射密码：y=ax+b(mod26)  ，条件：(k,26)=1，解密：x=(y-b)a^-1 mod 26（**关键计算a^-1,利用扩展欧几里得算法**）

密钥短语代替密码：选个短语，去掉其中的重复字母，而后再将字母表中未在字母串中出现过的字母依次写于此短语之后，就可以构造一个字母替换表

#### (2).Vigenere密码（分组代换）

定义密钥k=(k1,k2,k3...km),E=(x1+k1,x2+k2,......xm+km)   mod26

方法：分组，**每组长m**，按照k加密

#### (3).多表代换密码（分组二维仿射加密）

<img src="\Snipaste_2024-05-25_10-26-57.png" style="zoom:60%;" /> 

# 第二章.分组密码

## 1.概述

![](\Snipaste_2024-05-25_10-56-46.png) 

通常取n=m。

• 若n<m ，则为有数据扩展的分组密码。

• 若n>m ，则为有数据压缩的分组密码。

分组密码算法应满足的要求

1）**分组长度**n要足够大

2）**密钥量**要足够大

3）由密钥确定**置换的算法**要足够复杂

## 2.安全性设计原则

### 1.混淆原则

混淆原则就是将密文、明文、密钥三者之间的**统计关系**和**代数关系**变得尽可能复杂，使得敌手即使获得了密文和明文，也无法求出密钥的任何信息；即使获得了密文和明文的统计规律，也无法求出明文的新的信息。

### 2.扩散原则

让**明文**中的每一位**影响密文中的尽可能多的位**，或者说让密文中的每一位都受到明文中的尽可能多位的影响

## 3.SP网络（代换置换网络）

代换是输入集A到输出A’上的双射变换：

fk：A->A＇

实现代换fk的网络称作代换网络

### 代换盒(S盒)

在密码设计中，可选**n=r*n0**，其中r和n0都为正整数，将设计**n个变量**的代换网络化为设计r个较小的子代换网络，而每个**子代换网络只有n0个输入变量**。称每个子代换网络为代换盒

## 4.Feistel密码（乘积密码）

定义：乘积密码指**顺序地执行两个或多个基本密码系统**，使得最后结果的密码强度高于每个基本密码系统产生的结果

算法：输入是分组长为2w的明文和一个密钥K。将每组明文分成左右两半L0和R0，在进行完n轮迭代后，左右两半再合并到一起以产生密文分组。第i轮迭代的输入为前一轮输出的函数：

左：**Li = Ri-1**

右：**Ri =Li-1 ⊕ F(Ri-1,Ki)**

<img src="\Snipaste_2024-05-25_11-25-27.png" style="zoom:80%;" /> 

## 5.DES--64，56

• 分组长度为**<u>64 bits</u>** (8 bytes)

• 密文分组长度也是64 bits。

• 密钥长度为64 bits，有**8 bits奇偶校验**，有效密钥长度为**<u>56 bits</u>**。

• 算法主要包括：初始置换IP、16轮迭代的乘积变换、逆初始置换IP^-1以及16个子密钥产生器

<img src="\Snipaste_2024-05-25_11-43-10.png" style="zoom:80%;" /> ![](\Snipaste_2024-05-25_12-25-44.png) 

### 1.IP置换（64-64）

IP和IP-1在密码意义上作用不大，它们的作用在于**打乱原来输入x的ASCII码<u>字划分</u>的关系**。

<img src="\Snipaste_2024-05-25_11-49-37.png" style="zoom:60%;" /> 

### 2.轮函数

设输入为（x，y），轮函数输出为（y, x ⊕fk(y)）

它等价于两个对合变换的复合: (x,y) ↦ (x⊕f(k,y),y) ↦ (y,x⊕f(k,y))

<img src="\Snipaste_2024-05-25_11-59-00.png" style="zoom:80%;" /> 

### 3.S盒结构（48-32）

<img src="\Snipaste_2024-05-25_12-03-45.png" style="zoom:60%;" /> 

### 4.移位次数表（密钥生成的循环移位中）

<img src="\Snipaste_2024-05-25_12-38-34.png" style="zoom:100%;" /> 

### 5.填充（指示符PI）

给定加密消息的长度是随机的，按64 bit分组时，**最后一组消息长度可能不足64 bit**。可以填充一些数字，通常用**最后1字节作为填充指示符（PI）**。它所表示的十进制数字就是**填充占有的字节数**。

<img src="\Snipaste_2024-05-25_12-40-50.png" style="zoom:60%;" /> 

### 6.安全性

#### • 互补性

DES算法具有下述性质。若明文组x逐位取补，密钥k逐位取补，即y=DESk(x), 则有y补=DESk补(x补)这种互补性会使DES在选择明文破译下所需的工作量**减半**。

#### • 弱密钥

如果给定初始密钥k，**各轮的子密钥都相同**，即有k1=k2= … =k16，就称给定密钥k为**弱密钥**

• 弱密钥: EK*EK = I ，DES存在4个弱密钥

DESk(DESk(x))=x

• 半弱密钥: EK1 = EK2 ，至少有12个半弱密钥

y=Ek1(x)=Ek2(x)

#### • 攻击手段

**穷举密钥搜索攻击**（1997破解）

DES的其他攻击方法：

时间-空间权衡攻击、差分攻击、线性攻击和相关密钥攻击等方法，

在这些攻击方法中，线性攻击方法是最有效的一种方法

## 6.多重DES

大大提高**抵抗穷举密钥搜索攻击**的能力

### 1.双重DES的中间相遇攻击

已知明密文对(x1,y1),双重DES加密E-->-->D

1.以密钥**k1的所有**2^56个**可能的取值**对此明文x1**加密**

2.从**所有可能**的2^56个密钥**k2**中依任意次序选出一个对给定的密文y1**解密**，并将每次解密结果z在上述表中**查找**相匹配的值。一旦找到，则可确定出两个密钥k1和k2；

3.以此对密钥k1和k2对**另一已知明文密文对**(x2, y2)中的明文x2进行加密，如果能得出相应的密文y2就可确定k1和k2是所要找的密钥

密钥搜索量：<u>2*2<sup>56</sup></u>

可能的密钥数为2^112个。所以，在给定明文下，将有2^112/2^64 =2^48个密钥能产生给定的密文。?????????

### 2.三重DES

三重DES中三个密码组件**既可以是一个加密函数，也可以是一个解密函数**

#### 双密钥三重DES（EDE）

当**k1=k3**时，则称为双密钥三重DES

加密：y=Ek1[Dk2[Ek1 [x]]]

称其为**加密-解密-加密方案**，简记为EDE

密钥搜索量：<u>2<sup>112</sup></u>

## 7.分组密码的工作模式

**分组密码的工作模式**是：根据不同的数据格式和安全性要求, 以一个**具体的分组密码算法**（例DES）为基础**构造**一个**分组密码<u>系统</u>**的方法

• 需要采用适当的工作模式来隐蔽明文的<u>统计特性</u>、<u>数据的格式</u>等

### 1.电码本模式（ECB）

相同**明文分组**对应相同**密文分组**

特点：**不能隐蔽**明文分组的**统计规律**和结构规律,不能抵抗替换攻击

<img src="\Snipaste_2024-05-25_14-00-02.png" style="zoom:60%;" /> 

### 2.密码分组链接模式(CBC)--对异或的明文加密

先将明文分组与**上一次的密文块**进行按比特**异或**，然后再进行加密.

必须选择一个初始向量c0=IV，用于加密第一块明文

ci=Ek(mi⊕ci-1)

特点：明文块的**统计特性得到了隐蔽**

具有有限的(**两步**)**错误传播**特性

具有**自同步**功能（若从第t块起密文块正确,则第t+1个明文块就能正确求出）

<img src="\Snipaste_2024-05-25_14-00-10.png" style="zoom:60%;" /> 

### 3.密码反馈模式(CFB)--对Ij加密，明文异或

适用于**每次处理 r比特明文块**的**特定需求**的加密情形,能灵活适应数据各格式的需要

将上一次加密的结果放入Ij再左移，将Ij加密后取最左边的r项

必须选择一个初始向量IV=c-L+1…c-1 c0， |ci|=r，则加密过程可表示为:ci=xi⊕leftr(E(ci-L....ci-2ci-1))

特点：相同明文（改变IV同样会导致相同的明文输入得到不同的加密输出）

链接依赖性

错误的传播

错误恢复(自同步)

<img src="\Snipaste_2024-05-25_14-33-05.png" style="zoom:60%;" /> 

### 4.输出反馈模式(OFB)--对Ij加密，明文异或

结构上类似于CFB模式，但**反馈的内容**是**DES的输出**而不是密文

<img src="\Snipaste_2024-05-25_14-40-57.png" style="zoom:60%;" /> 

### 5.计数器模式(CTR)--对自然数加密，明文异或

特点：可以产生**伪随机数**序列

可**并行**加密

加密数据块的**随机访问**

<img src="\Snipaste_2024-05-25_14-43-16.png" style="zoom:60%;" /> 

### 应用

#### 利用CBC模式实现报文的完整性认证

n个明文分组m=(m1,....,mn),**校验码**为r=mn+1=m1⊕....⊕mn,**认证码**为Cn+1=r加密后对应项

(1) 仅需对明文认证,而不需加密时,传送明文m和认证码Cn+1，此时也可仅保留Cn+1的 t 个比特作为认证码；

(2) 既需对明文认证,又需要加密时,传送密文C和认证码Cn+1

对应(1),**验证者**接收到明文(校验码)和认证码，需要对(m,r)**加密**，将得到的最后一个密文分组与认证码Cn+1比较

对应(2),**验证者**接收到密文(认证码)，需要对密文进行**解密**，得到明文和校验码，再进行验证操作

## 8.域

### 1.域

对于任一不可约多项式f(x)，F[x]/(f(x))为域

F[x]/(f(x))={r(x)=rn-1*x^n-1+rn-2*x^n-2+…+r1*x+r0|ri∈F, 0≤i≤n-1}

AES将每一字节(8位)看作是有限域GF(2^8)上的一个元素,也可表示为一个两位的十六进制数

01101011，    b7x^7+b6x^6+b5x^5+b4x^4+b3x^3+b2x^2+b1x^1+b0,       6B

### 2.GF(2^8)中的运算

加法：和的系数模2

乘法：乘积模一个次数为8的不可约二进制多项式

### 3.乘法简便运算**xtime(x)**

函数xtime(x)定义为GF(2)上的x·b(x)=b7x<sup>8</sup>+b6x<sup>7</sup>+b5x<sup>6</sup>+b4x<sup>5</sup>+b3x<sup>4</sup>+b2x<sup>3</sup>+b1x<sup>2</sup>+b0x mod m(x)

若b7 =0，则x·b(x)的结果就是把字节b左移一位，且在最右边补上上0；

若b7 =1，则先对b(x)在字节内左移一位（最后一位补0），则再与‘1B’（00011011）做逐比特异或。

x-->02,即x·b(x)='02'·b(x),同理可以快速算出'04'·b(x)='02'·'02'·b(x),最后要求的y·b(x)中y用01,02,04等加得，再展开计算

### 4.多项式可逆

系数在GF(2<sup>8</sup>)上的**多项式**a3x<sup>3</sup>+a2x<sup>2</sup>+a1x+a0是模x<sup>4</sup>+1**可逆**的，**当且仅当**矩阵

**a0  a3  a2  a1**

**a1  a0  a3  a2**

**a2  a1  a0  a3**

**a3  a2  a1  a0**

在GF(2^8)上**可逆**

## 9.AES（Rijndael）--128，128/192/256

没有采用Feistel结构（而是SP网络），轮函数由3个不同的**可逆均匀变换**构成的，称为**3个层**(均匀变换是指状态的每个bit都用类似的方法处理)

• **线性混合层**

确保多轮之上的高度**扩散**；

• **非线性层**

将具有最优的“最坏情况非线性特性”的S盒并行使用，确保**混淆**特性；

• **密钥加层**

单轮子密钥简单的异或到中间状态上，实现**一次性掩盖**

<img src="\Snipaste_2024-05-25_16-00-58.png" style="zoom:80%;" /> 

AES明文**分组固定为128比特**

**状态**(中间结果)：列数**Nb**为分组长度除32，行数为4（一列有32位，32位正好表示成一个四次多项式，每个系数一字节，即系数模256，也可以说是系数是两位的16进制数）(表中一个元素即为一个系数，也是一个字节)

**种子密钥**：列数**Nk**为密钥长度除32，行数为4

**轮数**：**Nr**<img src="\Snipaste_2024-05-25_16-17-20.png" style="zoom:60%;" /> 



### 1.字节代换   ByteSub

**S盒设计**：y=Ax^-1+B(S盒输入最大为ff，即64，即8比特，即1字节)

对状态的**每个字节**进行两步

(1) 将字节作为GF(2^8)上的元素**映射到自己的逆元**'模x^4+1'

(2) 将字节做GF(2)上的仿射变换,即**y=Ax^-1+B**(A为8*8矩阵，B为列向量)

<img src="\Snipaste_2024-05-25_16-10-16.png" style="zoom:60%;" /> 

逆字节变换：x=(A^-1(y-B))^-1

### 2.行移位  ShiftRow

各行进行循环**左移**，不同行的移位量不同<img src="\Snipaste_2024-05-25_16-17-08.png" style="zoom:60%;" /> 
0行：不动

1行：循环左移C1**字节**

2行：循环左移C2字节

3行：循环左移C3字节

逆行移位：改为循环**右移**，行数对应移动字节数和前面一样

### 3.列混淆   MixColumn

将**每列**（4字节）视为GF(2^8)上多项式，**与固定的多项式<u>c(x)</u>进行模x^4+1乘法**（系数为模64，即两位的16进制数），记为⊗ ,要求c(x)模x^4+1可逆

例：系数运算 '03'+'02'+'11'='16'

逆列混淆：将状态矩阵中的**每列**视为系数在GF(2^8)上的次数小于4的多项式**与同一个固定的多项式 <u>d(x)</u>相乘**，d(x)满足<u>d(x)</u>⊗<u>c(x)</u>='01'

### 4.轮密钥加   AddRoundKey

**轮密钥**与**状态**进行逐比特**异或**

### 5.密钥编排

指从种子密钥得到轮密钥的过程，它由密钥扩展和轮密钥选取两部分组成

• （1）**轮密钥的总比特数**(**扩展密钥比特数**)等于分组长度乘以(轮数加1)；例如要将128比特的明文经过10轮的加密，则总共需要（10+1）																																												·128=1408比特的密钥。

•（2）扩展：**种子密钥(128/192/256)**被扩展成为**扩展密钥(128·(Nr+1))**；

•（3）选取：**轮密钥**(128)从扩展密钥中取，其中第1轮轮密钥取扩展密钥的前(128)个字，第2轮轮密钥取接下来的(128)个字，如此下去

## 10.SM4--128，128

分组长度和密钥长度均为128比特，共32轮

轮函数：**Xi+4=Xi⊕T(Xi+1⊕Xi+2⊕Xi+3⊕rki)**---第i-1轮

(K0,K1,K2,K3)=(MK0⊕FK0,MK1⊕FK1,MK2⊕FK2,MK3⊕FK3)----加密密钥MK=(MK0,MK1,MK2,MK3)=128

轮密钥：**rki=Ki+4=Ki⊕T'(Ki+1⊕Ki+2⊕Ki+3⊕CKi)**---32位

S盒设计：y=A(Ax+B)^-1+B(比AES的S盒设计多了一个仿射变换)

<img src="\Snipaste_2024-05-25_18-04-15.png" style="zoom:80%;" /> 

<img src="\Snipaste_2024-05-25_18-04-24.png" style="zoom:80%;" /> 轮函数

<img src="\Snipaste_2024-05-25_18-22-16.png" style="zoom:60%;" /> 轮密钥

# 第三章.序列密码

## 1.流密码(序列密码)

### 1）一次一密密码

密钥仅用一次的单表代替密码的**加法密码**

• 优点：

**密钥随机产生**，仅使用一次

**无条件安全**

加密和解密为加法运算，效率较高

• 缺点：

**密钥长度至少与明文长度一样长**，密钥共享困难，不太实用

### 2）流密码定义

流密码主要是**基于硬件**实现

利用**密钥k**产生一个**密钥流**z=z0z1z2…，并使用如下规则对明文串x=x0x1x2…加密：

y=y0y1y2…＝E0(x0)E1(x1) E2(x2)…，（Ei(xi)=Ezi(xi),即在zi条件下的加密E）

zi＝f(k,σi)   ---σi是加密器中的记忆元件在时刻 i 的状态

内部记忆元件由一组移位寄存器构成

### 3）同步流密码

内部记忆元件的**状态σi独立于明文字符**的叫做**同步流密码**，否则叫做自同步流密码

### 4）加法流密码

<img src="\Snipaste_2024-05-26_09-17-24.png" style="zoom:60%;" /> 

yi=zi⊕xi

一次一密密码是加法流密码的原型，如果密钥用作滚动密钥流，则加法流密码就**退化成一次一密密码**

### 5）密钥流序列应具有的性质

Ø **极大的周期**

Ø 良好的**统计特性**

Ø **抗线性分析**

## 2.二元序列的伪随机性

### 1）二元序列

定义：**GF(2)上**的一个无限序列a=(a1,a2....an,....)称为二元序列，若ai属于GF(2) 。

周期L/p(a)：L是满足对于一切正整数k都有ak=ak+L的**最小正整数**

游程：**一个周期**的数**排成圆周**，相邻的1称为1的游程，1的个数为1游程的长度，0亦然。

#### 自相关函数：

<img src="\Snipaste_2024-05-26_09-30-56.png" style="zoom:60%;" /> 

### 2）伪随机序列

#### 1.Golomb伪随机公设：

① 在序列的一个周期内，0与1的个数**相差至多为1**。(0,1出现概率相同)

② 在序列的一个周期内，**长为i的游程**占游程总数的**1/2^i**(i=1,2,…)，且在**等长的游程**中0的游程个数和1的游程**个数相等**。（0，1每一位置出现概率相同）（长1->1/2,长2->1/4）

③ **异相自相关函数**是一个**常数**。（对序列与其平移后的序列做比较，不能给出其他任何信息）

#### 2.伪随机序列定义

二元序列a，对一切    t=/=0(modp(a)),      有**R(t)=-1**,则a为伪随机序列

#### 3.伪随机序列还应满足的条件

周期p要足够大

序列易于高速生成

不可预测性：序列任何部分暴露，分析整个序列不可行

## 3.线性反馈移位寄存器

### 1）反馈移位寄存器   FSR

一个n级反馈移位寄存器由**n个二元存储器**与一个**反馈函数**f(a1,a2,…,an)组成-----------------(f为**布尔函数**：函数的自变量和因变量只取0和1)

<img src="\Snipaste_2024-05-26_09-48-49.png" style="zoom:60%;" /> 状态：(a1,a2,…,an)

### 2）线性反馈移位寄存器  LFSR

反馈函数**f(a1,a2...an)=c1an⊕c2an-1......cna1**

**结构常数**为[c1,c2,.....cn]

<img src="\Snipaste_2024-05-26_09-52-35.png" style="zoom:60%;" /> 

总是假定c1,c2,…,cn中至少有一个不为0，否则f(a1,a2,…,an)≡0。总是**假定cn=1**。（即总是有a1）

LFSR输出序列的性质：完全由其反馈函数决定。

n级LFSR的状态周期： <= 2<sup>n</sup>-1(状态共2^n种)

输出序列的周期=状态周期，<=2<sup>n</sup>   -1

使序列的**周期达到最大值2<sup>n</sup>-1的序列称为m序列**

## 3+.m-序列（特殊的LFSR：周期达到最大值2^n   -1）

LFSR的**特征多项式p(x)**：<img src="\Snipaste_2024-05-26_10-25-24.png" style="zoom:60%;" /> （反馈函数第i项为p(x)的第i+1项）

序列的**生成函数A(x)**：幂级数<img src="\Snipaste_2024-05-26_10-25-10.png" style="zoom:60%;" /> 

**G(p(x))**:p(x)的的非零全体可能值(2<sup>n </sup>  -1个)

定理：A(x)满足条件：<img src="\Snipaste_2024-05-26_10-28-11.png" style="zoom:60%;" /> <img src="\Snipaste_2024-05-26_10-28-16.png" style="zoom:60%;" /> ai为初始状态，即φ(x)由初始状态决定

**p(x)的阶/周期**：使p(x)|(x<sup>p</sup>  -1)成立的最小正整数p（p(x)的阶总是大于等于p(x)的次数）（p(x)次数为n，周期为p）

定理：p(x)|q(x)的充要条件是G(p(x))被包含于G(q(x)---说明：可用n级LFSR产生的序列，也可用级数更多的LFSR来产生

定理：若序列{ai}的特征多项式p(x)定义在GF(2)上，p是p(x)的周期，则{ai}的周期r|p---说明：n级LFSR输出序列的周期r，不依赖于初始条                      																																										件，而依赖于特征多项式p(x)

定理：设p(x)是n次不可约多项式，周期为m，序列{ai}∈G(p(x))，则{ai}的周期为m。

定理：n级LFSR产生的序列有最大周期2^n  -1的必要条件是其特征多项式为不可约的

**本原多项式**：若n次**<u>*不可约*</u>**多项式p(x)的**<u>*阶为2<sup>n</sup>  -1*</u>**，则称p(x)是n次本原多项式

定理：设{ai}∈G(p(x))，{ai}为m序列的充要条件是p(x)为本原多项式（**<u>*m序列<=>p(x)是本原多项式*</u>**）

### m-序列的安全性

输出序列即为密钥流，可以由明文和密文异或得到（明文+密文->密钥流->序列->递推式）

#### 1.解方程法

已知序列{ai}是由n级线性移存器产生的，并且知道{ai}的**连续2n位**，可用解线性方程组的方法得到反馈多项式

设出线性递推式，再将序列带入得方程组求解ci

<img src="\Snipaste_2024-05-26_11-29-56.png" style="zoom:60%;" /> 

#### 2.Berlekamp-Massey算法（B-M算法）

**线性综合解**：<f(x),L>    ----f(x)为特征多项式，L为级数

1.取初始值：<img src="\Snipaste_2024-05-26_11-43-08.png" style="zoom:60%;" />                注： <img src="\Snipaste_2024-05-26_11-47-33.png" style="zoom:60%;" /> 

2.计算dn步差值<img src="\Snipaste_2024-05-26_11-42-01.png" style="zoom:60%;" /> 

(i)若dn=0,令<img src="\Snipaste_2024-05-26_11-42-59.png" style="zoom:60%;" />

(ii)若dn=1,<img src="\Snipaste_2024-05-26_11-44-01.png" style="zoom:60%;" /> 

​	

<img src="\Snipaste_2024-05-26_11-39-58.png" style="zoom:80%;" /> 

## 4.非线性序列

### 1）密钥流生成器

密钥流生成器可分解为驱动子系统和非线性组合子系统<img src="\Snipaste_2024-05-26_12-24-43.png" style="zoom:60%;" /> 
• **驱动子系统**常用一个或多个**线性反馈移位寄存器**来实现

• **非线性组合子系统**用**非线性组合函数F**来实现

### 2）Geffe序列生成器（含3个LFSR）

Geffe序列生成器由**3个LFSR**组成

• 当LFSR2输出1时，LFSR2与LFSR1相连接

• 当LFSR2输出0时，LFSR2与LFSR3相连接

LFSRi的特征多项式分别为ni次**本原多项式**（**m序列**），且**ni 两两互素**

 <img src="\Snipaste_2024-05-26_13-29-00.png" style="zoom:80%;" /><img src="\Snipaste_2024-05-26_13-27-12.png" style="zoom:80%;" /> =n1n2+n3(1-n2)=n1n2+n3+n2n3=(n1+n3)n2+n3

<img src="\Snipaste_2024-05-26_13-27-41.png" style="zoom:60%;" /> <img src="\Snipaste_2024-05-26_13-27-49.png" style="zoom:60%;" /> =bk

（三个m序列相乘）

### 3）J-K触发器（含0个LFSR）

J-K触发器输入端一般为**2个LFSR**

<img src="\Snipaste_2024-05-26_13-42-28.png" style="zoom:60%;" /> <img src="\Snipaste_2024-05-26_13-42-35.png" style="zoom:80%;" /> ⥄等同于 · ，即乘法

<img src="\Snipaste_2024-05-26_13-42-56.png" style="zoom:80%;" /> 

​																					（两个m序列相乘）

**JK弱点：**如果知道{ck}中相邻位的值ck-1和ck，就可以推断出ak和bk中的一个。就可通过密码分析的方法得到序列{ak}和{bk}

故设计<u>Pless生成器</u>克服<u>利用J-K触发器的非线性序列生成器</u>的弱点

### 4）Pless生成器（含8个LFSR）

Pless生成器由**8个LFSR**、**4个J-K触发器**和**1个循环计数器**构成

<img src="\Snipaste_2024-05-26_13-50-33.png" style="zoom:80%;" /> 

### 5）钟控序列生成器（含2个LFSR）

是用一个LFSR控制另外一个LFSR的移位时钟脉冲

•当**LFSR1输出1**时，移位时钟脉冲通过与门使LFSR2**进行一次移位**，从而**生成下一位**。

• 当**LFSR1输出0**时，移位时钟脉冲无法通过与门影响LFSR2。因此LFSR2**重复输出前一位**。

<img src="\Snipaste_2024-05-26_13-59-17.png" style="zoom:80%;" /> 

• 若{ak}和{bk}的极小特征多项式分别为GF(2)上的m和n次<u>**本原多项式**</u>f1(x)和f2(x)，且**<u>m|n</u>**，则<img src="\Snipaste_2024-05-26_14-07-02.png" style="zoom:100%;" /> 

<img src="\Snipaste_2024-05-26_14-15-41.png" style="zoom:60%;" /> （将f2(x）中的x替换为x<sup>2<sup>m</sup> -1</sup>

<img src="\Snipaste_2024-05-26_14-25-57.png" style="zoom:60%;" /> 特征多项式(n+1项)第一项不用,反馈函数(n项)都用

<img src="\Snipaste_2024-05-26_14-26-04.png" style="zoom:60%;" /> 

<img src="\Snipaste_2024-05-26_14-40-20.png" style="zoom:60%;" /> 

# 第四章.公钥密码

## 1.公钥密码体制（非对称密码体制）

### 概念：

• 每个用户生成一个密钥对：一个公钥pk和一个对应的私钥 sk

• 公钥将在系统内被公开

• 私钥由用户本人安全保管

### 公钥密码的主要作用

• 公钥加密

任何人可以用**公钥加密**消息，**私钥**的拥有者可以**解密**消息

• 数字签名 (Digital Signature) 

**私钥**的拥有者**生成数字签名**，任何人可以用**公钥验证签名**

• 基于公钥的密钥分配(Key Distribution)

### 公钥密码体制的优势

• 密钥分发：公钥能够采用**公开**（认证的）信道进行**传输**；

• 密钥管理：在用户N个用户的系统中，每个用户只需安全保管自己的**私钥**和**N-1个**其他用户的**公钥**。整个系统仅仅需要**维护N个公钥**；（对称密码要N(N-1)/2）

• 开放系统：即使是**没有预先建立关系**的用户也能通过对方的公钥建立安全通信。

### 公钥密码的理论基础: **陷门单向函数**

## 2.计算复杂性

算法的计算时间和存储空间（分别称为算法的**时间复杂度**和**空间复杂度**）定义为算法输入数据的长度 n 的函数f(n)

若算法的时间复杂度为**T=O(n<sup>k</sup>)** ，则称该算法是**多项式时间**的；（T=O(n<sup>5</sup>)）

若**T=O(k<sup>f(n)</sup>)**，其中k是常数， f(n)是多项式，就称该算法是**指数时间**的。（T=O(2<sup>n</sup>)）

## 3.P和NP问题

**P问题**是指可以在多项式时间内判定的语言集合(**求解)**

**NP问题**是指可在多项式时间内验证它的一个解的问题。(**验证**)

因为求解(P)比验证(NP)更困难，故P∈NP

## 4.几个困难问题

大整数分解问题:n=pq，求n容易，求p，q困难

离散对数问题:y=g<sup>x</sup>(modp)，求y容易，求x困难

多项式求根问题:多项式，求y容易，求x困难

二次剩余问题:x<sup>2</sup>≡a(modn)，n分解未知时求x困难

背包问题:A= (ai),x=(xi),s=a1x1+...anxn，求s容易，求x困难

MQ问题:求解有限域上任意选取的多变量二次多项式方程组问题

<img src="\Snipaste_2024-05-26_15-57-58.png" style="zoom:60%;" /> 

<img src="\Snipaste_2024-05-26_15-57-47.png" style="zoom:60%;" /> 利用函数f构造签名

<img src="\Snipaste_2024-05-26_15-58-56.png" style="zoom:60%;" /> 

## 5.RSA

### 1）原理

• 选取两互异大素数p和q

• 计算 n=p×q 和其欧拉函数值φ(n)=(p－1)(q－1)

• 选一整数e，1 < e<φ(n)，使得 gcd(φ(n), e)=1

• 在模φ(n)下，计算e的逆元d. 即求d, 使得ed ≡ 1 mod φ(n)

• 以(n，e )为公钥。d 为秘密钥。

将明文分组，分组大小小于n

加密 c =E(m)≡ m<sup>e</sup> mod n

解密 m = D(c)≡ c<sup>d</sup> mod n

RSA解密正确性证明：1.m，n互素-欧拉定理-c^d^=m^kφ(n)+1^=m modn

2.不互素-设m=xp,m<sup>φ(q)</sup>=1 modq->m<sup>φ(n)</sup>=1 modq->m<sup>φ(n)</sup>=1+rq->m<sup>φ(n)+1</sup>=m+rxpq->m<sup>φ(n)+1</sup>=m+rxn=m modn

### 2）计算

#### 1.模整数幂

(a×b) mod n=[(a mod n)×(b mod n)] mod n               **先乘再模->先模再乘**

#### 2.快速指数算法

<img src="\Snipaste_2024-05-26_16-43-08.png" style="zoom:80%;" /> 

#### 3.Miller-Rabin算法（概率素性检测）

引理：如果p为大于2的素数，则方程x^2≡1(mod p)的解只有x≡1和x≡-1。

引理的逆否命题为：如果方程x^2≡1 mod p有一解x0 {-1,1}，那么p不为素数

(Fermat)若p是素数，a是正整数且gcd(a, p)=1，则a<sup>p-1</sup>≡1 mod p

<img src="\Snipaste_2024-05-26_16-58-22.png" style="zoom:80%;" /> 

只要有一次算法返回为False，就可肯定n不是素数。

如果算法每次返回都为True，则n是素数的概率至少为1-4<sup>-s</sup>

### 3）RSA安全性

模数长度应该介于1024bit到2048bit之间

确定φ(n)等价于分解了n

#### 对p和q 提出以下要求

（1） p - q 要大:如果|p-q|小,则(p+q)/2稍大于n^0.5,则可在n^0.5附件找到整数x使x^2-n=y^2(y是整数),即n=(x+y)(x-y)

（2）p -1和 q -1 都应有大素因子:设攻击者截获密文 c ，可进行重复加密,直到c^(e^t)=c,即m<sup>e<sup>t+1</sup></sup>=m<sup>e</sup>,即m<sup>e<sup>t</sup></sup>=m,即得到m

#### 对RSA的攻击

1.共模攻击:如果两次加密(公钥e1,e2)的m相同，且e1,e2互素，可用扩展欧几里得恢复m--找到r,s使re^1+se^2=1,构造m^(re^1+se^2)

2.低指数攻击：如果每个用户的加密指数都很小,且m相同，可用中国剩余定理恢复m

3.选择密文攻击---->RSA是确定性的加密算法, 不能抵御选择密文攻击：攻击者已知c1,构造c2=c1m2^e给挑战者解密得m2'，

m<sub>2</sub>'=c1<sup>d</sup>*m<sub>2</sub>=m1*m2,故m<sub>1</sub>=m<sub>2</sub>'*m<sub>2</sub><sup>-1</sup>

## 6.ElGamal密码体制

### 1）Diffie-Hellman密钥交换

基于求**离散对数的困难性**

<img src="\Snipaste_2024-05-26_18-37-11.png" style="zoom:60%;" /> 

### 2）ElGamal密码体制

#### 1.原理

1. 密钥产生过程： 选择一素数p以及小于p的随机数x， g是p的原根,计算y≡g<sup>x</sup> mod p。

  **(y, g, p)**作为公开密钥，**x**作为秘密密钥。

2. 加密过程： 明文消息M，随机选一整数 k<p-1，计算

  **C1≡g<sup>k</sup>** （mod p）, **C2≡y<sup>k</sup>M** （mod p）

  密文为**C=(C1,C2)**。

3. 解密过程：

  **M=c2(c1<sup>x</sup>)<sup>-1</sup>** (mod p)

#### 2.特点

1. 安全性基于有限域上的**离散对数**的难解性
2. 加密算法是**概率算法**
3. **不能**抵御**选择密文**攻击（作业）
4. 存在**密文扩张**

#### 3.参数要求

• p应为**150位以上十进制数**，500位以上的二进制数，**p-1应有大素数因子**。

• **K**必须保密而且必须是**一次性**的。

## 7.椭圆曲线密码体制 ECC（了解）

### 1）椭圆曲线

#### 常用方程

y<sup>2</sup>≡x<sup>3</sup>+ax+b(mod p)    （p为一大素数）(a,b∈GF(p),4a<sup>3</sup>+27b<sup>2</sup>≠0(modp))

#### 加法

① P+O=P。

② 如果P=(x,y)，那么(x, y)+(x, -y)=O   （曲线关于x轴对称）

③ 设P=(x1,y1)，Q=(x2,y2)，P≠-Q（斜率存在），则P+Q=(x3,y3)由以下规则确定：

<img src="\Snipaste_2024-05-26_18-43-45.png" style="zoom:80%;" /> 

#### 困难问题

P∈Ep(a,b), **P的阶是一个非常大的素数**，(P的阶是满足nP=O的最小正整数n，阶即指加法的最小循环周期)

Q=kP，(即k个p点相加)

(1) 已知k和P易**求Q**;

(2) 已知P、Q**求k**则是**困难**的

### 2）椭圆曲线实现ElGamal密码体制

<img src="\Snipaste_2024-05-26_18-52-32.png" style="zoom:80%;" /> 

#### 原理

p>3大素数，生成元G的阶足够大，取随机整数d,(1<=d<=ord(G)-1)--随机整数k,(1<=k<=ord(G)-1)  

Q=dG							   y=g<sup>x</sup> modp

明文Pm							明文M

密文C={kG,Pm+kQ}         C=(g<sup>k</sup>,y<sup>k</sup>M)     指变乘，乘变加

解密Pm=Pm+kQ-dkG	   解密M=c2(c1<sup>x</sup>)<sup>-1 </sup>    -1次变减

公钥：Q,G,E					y,g,p

私钥：d							x

#### 明文消息嵌入到椭圆曲线上

设明文消息为m, k是一个足够大的整数(例如30)

计算x={mk+j,j=0,1,2....29}

直到x<sup>3</sup>+ax+b(modp)有平方根，则得到点Pm的分量x

解点只需m=x/30(向下取整)

#### 椭圆曲线密码体制的优点

1. 安全性高

2. 密钥量小

3. 灵活性好

# 第五章.消息认证和哈希函数

## 1.消息认证机制

•抗击被动攻击：加密

•抗击主动攻击：消息认证

•消息认证机制需要产生认证符（用于认证消息的数值）

•认证符的产生方法：消息认证码MAC、Hash函数

### 1）消息认证码 MAC

MAC=M||C<sub>K</sub>(M)   		-------------------K:A和B的共享密钥    C():MAC函数（不必可逆）

• 如果仅收发双方知道K，且B**计算得到的MAC**与**接收到的MAC**一致，则这一就实现了以下功能：
① 接收方相信发送方发来的消息**未被篡改**。
② 接收方相信发送方**不是冒充**的

<img src="\Snipaste_2024-05-27_18-06-06.png" style="zoom:80%;" /> 

<img src="\Snipaste_2024-05-27_18-06-27.png" style="zoom:80%;" /> 

#### MAC函数应满足的条件

1.如果敌手得到M和C<sub>K</sub>(M)，则构造一满足C<sub>K</sub>(Mʹ)=C<sub>K</sub>(M)的新消息Mʹ在计算上是不可行的。

2.C<sub>K</sub>(M)在以下意义下是均匀分布的： 随机选取两个消息M、Mʹ，Pr[C<sub>K</sub>(M)=C<sub>K</sub>(Mʹ)]=2<sup>-n</sup>，其中n为MAC的长。

3.若Mʹ是M的某个变换，即Mʹ=f(M)，例如f为插入一个或多个比特，那么Pr[C<sub>K</sub>(M)=C<sub>K</sub>(Mʹ)]= 2<sup>-n</sup>。

### 2）Hash函数（杂凑函数，散列函数）

定义：将任意长的消息M映射为**较短的**、**固定长度**的一个值**H(M)**。

#### Hash函数满足条件

1.Hash函数函数的**输入可以是任意长**

2.Hash函数函数的**输出是固定长**

3.易于在软件和硬件实现

#### Hash函数满足的安全条件

**单向性**：已知x，求H(x)较为容易；但是，已知h，求使得H(x)=h的x在计算上是不可行的。

**弱抗碰撞性**：**已知x**，**找出y**(y≠x)使得**H(y)=H(x)**在计算上是不可行的。

**强抗碰撞性**：**找出任意**两个不同的输入**x、y**，使得**H(y)=H(x)**在计算上是不可行的。

关系：强抗碰撞性=>弱抗碰撞性=>单向性

<img src="\Snipaste_2024-05-27_18-45-59.png" style="zoom:60%;" /> 认证：H(M)------1

<img src="\Snipaste_2024-05-27_18-46-08.png" style="zoom:60%;" /> 认证：E(H(M))------2

<img src="\Snipaste_2024-05-27_18-48-38.png" style="zoom:60%;" /> 认证：D(H(M))------3

<img src="\Snipaste_2024-05-27_18-48-45.png" style="zoom:60%;" /> 认证：D(H(M))

<img src="\Snipaste_2024-05-27_18-48-54.png" style="zoom:60%;" /> 认证：H(M||S)------4

<img src="\Snipaste_2024-05-27_18-49-03.png" style="zoom:60%;" /> 认证：H(M||S)

认证有四种：---------H(M),-----------E(H(M)),----------D(H(M)),----------H(M||S)

加密有一种：都是-------------E(认证后的数据||M)

加解密中至少含有一个E/D/S

#### 生日攻击

1.**第Ⅰ类生日攻击**：已知一杂凑函数H有n个可能的输出，H(x)是一个**特定**的输出，如果对H随机取k个输入，则至少有一个输入y使得H(y)=H(x)的<u>概率为0.5</u>时，k有多大？(**弱抗碰撞性**)

一个相同的都没有的概率Q：1-(1-1/n)<sup>k</sup>≈1-(1-k/n)=k/n--------------至少一个相同概率P：**1-k/n**

如果H的输出为m比特长，即可能的输出个数n=2<sup>m</sup>,带入得k/n=k/2<sup>m</sup>=0.5  =><u>k=n/2</u>  => k=2<sup>m-1</sup>

2.**第Ⅱ类生日攻击**：设杂凑函数H有n个可能的输出，如果H的k个随机输入中至少有两个产生相同输出的概率大于0.5，k有多大？(强抗碰撞性)

任意两个都不同的概率P：<sup>C<sup>k</sup><sub>n</sub></sup>/<sub>n<sup>k</sup></sub>=<sup>n!</sup>/<sub>(n-k)!n<sup>k</sup></sub>-----------------至少有一个相同的对的概率P：**1-<sup>n!</sup>/<sub>(n-k)!n<sup>k</sup></sub>**

如果H的输出为m比特长，即可能的输出个数n=2<sup>m</sup>,带入得<u>k≈&#8730;(n)</u>=&#8730;(2<sup>m</sup>)   =2<sup>m/2</sup> =>k=2<sup>m/2</sup>

<u>***生日攻击给出了消息摘要长度(Hash函数的输出长度)的下界***</u>

## 2.SHA(安全杂凑算法)

### 1）SHA-1（2<sup>64</sup>,512,160）

**基于MD4**

算法的输入：小于**2<sup>64</sup>**比特长的任意消息，分为**512**比特长的**分组**。

算法的输出：**160**比特长的消息摘要。

<img src="\Snipaste_2024-05-27_20-56-41.png" style="zoom:80%;" /> 

#### i.对消息填充

使得其比特长在**模512下为448**(512-64),填充内容：**第一位1，后全0**

#### ii.附加消息的长度

留出的64比特以表示**消息**被填充前的**长度**,(如果>**2<sup>64</sup>**则取模)

#### iii.对MD缓冲区初始化

使用**160比特**长的**缓冲区**存储中间结果和最终杂凑值,缓冲区为**5个32比特**以<u>big-endian</u>(数据的高字节保存在内存的低地址)方式存储数据的**寄存器(A, B, C, D, E)**

#### iv.以分组为单位对消息进行处理

每一分组Yq都经一**压缩函数处理**

#### v.输出消息

#### #####SHA的压缩函数

<img src="\Snipaste_2024-05-27_21-40-21.png" style="zoom:80%;" /> 

SHA的压缩函数由**4轮处理**过程组成，**每轮**处理过程**20步迭代**运算组成,再**与输入的CV<sub>q</sub>相加**，以产生CV<sub>q+1</sub>（其中加法是缓冲区5个字中的每一个字与CV<sub>q</sub>中相应的字模2<sup>32</sup>相加）

一步迭代图<img src="\Snipaste_2024-05-27_21-47-13.png" style="zoom:60%;" /> 

<img src="\Snipaste_2024-05-27_21-59-56.png" style="zoom:80%;" /> 

### 2）SHA系列

<img src="\Snipaste_2024-05-27_22-08-02.png" style="zoom:60%;" /> 

## 3.SM3（2<sup>64</sup>,512,256）

算法的输入：小于**2<sup>64</sup>**比特长的任意消息，分为**512**比特长的**分组**。

算法的输出：**256**比特长的消息摘要。

<img src="\Snipaste_2024-05-28_10-09-42.png" style="zoom:80%;" /> 

填充并附加消息的长度:使得其比特长在模512下为448(512-64),填充内容：第一位1，后全0

消息扩展:对消息分组进行消息扩展

迭代压缩:V<sup>i+1</sup>=CF(V<sup>i</sup>,B<sup>i</sup>)-------------CF是压缩函数，V<sup>0</sup>为初值IV，B<sup>i</sup>为填充后的消息分组(512)

<img src="\Snipaste_2024-05-28_10-21-49.png" style="zoom:60%;" /> 

<img src="\Snipaste_2024-05-28_10-18-57.png" style="zoom:60%;" /> 

**布尔函数GG<sub>j</sub>(X,Y,Z)和FF<sub>j</sub>(X,Y,Z)**是**非线性函数**，经过循环迭代后提供**混淆作用**
**置换函数P<sub>0</sub>(X)和P<sub>1</sub>(X)**是**线性函数**，经过循环迭代后提供**扩散作用**

## 4.HMAC

HMAC:将哈希函数用于构造MAC的方法

### HMAC设计目标：

① 可不经修改而**使用现有的哈希函数**

② 哈希函数可**易于替换**

③ **保持**镶嵌的哈希函数的**最初性能**，不因用于HMAC而使其性能降低。

④ 以**简单**方式**使用和处理密钥**。

⑤ 在对镶嵌的哈希函数合理假设的基础上，**易于分析**HMAC用于认证时的**密码强度**。

### 原理：

HMAC<sub>k</sub>＝H[(   K⊕opad)    ||    H[(K⊕ipad)||M]   ]

<img src="\Snipaste_2024-05-28_10-48-44.png" style="zoom:80%;" /> 

K<sup>+</sup>与ipad逐比特异或以及K<sup>+</sup>与opad逐比特异或的结果是将K中的**一半比特取反**，但两次取反的比特的**位置不同**
而**S<sub>i</sub>和S<sub>0</sub>**通过哈希函数中压缩函数的处理，则相当于以伪随机方式**从K产生两个密钥**

<img src="\Snipaste_2024-05-28_10-50-35.png" style="zoom:60%;" /> 这两个量的预先计算只在每次**更改密钥**时才需进行

###  攻击：

1.攻击者能够计算**压缩函数(哈希函数)的一个输出**，即使IV是随机的和秘密的---**IV可视为HMAC的密钥**

2.攻击者能够找出**哈希函数的碰撞**，即使IV是随机的和秘密的

第二种攻击对MD5的攻击复杂度为O(264)就现在的技术来说，这种攻击是可行的。但这是否意味着MD5不适合用于HMAC？

否。

攻击者在攻击MD5时，可选择任何消息集合后离线寻找碰撞。由于**攻击者知道哈希算法和默认的IV**，因此能为自己产生的每个消息求出哈希值。

然而，在攻击HMAC时，由于攻击者不知道密钥K，从而不能离线产生消息和认证码对

# 第六章.数字签名

## 1.基本概念

### 1）概念

数字签名：用于对数字消息签名,以防**消息的伪造或篡改**,也可用于通信双方的**身份鉴别**

签名算法：s=Sig<sub>x</sub>(m)

验证算法：Ver<sub>y</sub>(s, m)

### 2）数字签名应具有的特性

（1）签名是**可信**的：任何人可验证签名的有效性。

（2）签名是**不可伪造**的：除合法签名者外，其他人伪造签名是困难的。

（3）签名是**不可复制**的：一消息的签名不能复制为另一消息的签名。

（4）签名的**消息**是**不可改变**的：经签名的消息不能被篡改。

（5）签名是**不可抵赖**的：签名者事后不能否认自己的签名。

### 3）数字签名、消息验证码区别

数字签名：对身份认证，保持数据完整性、**不可否认性**。

MAC：对身份认证，保持数据完整性，但**不具有不可否认性**。



## 2.RSA数字签名

加密：c≡m<sup>e</sup> mod n   解密：m≡c<sup>d</sup> mod n

验证：s<sup>e</sup><sub>=</sub><sup>?</sup>m            签名：s≡m<sup>d</sup> mod n  

### 缺点：

（1）对任意s∈Z<sub>n</sub>，任何人可计算m≡s<sup>e</sup> mod n，因此任何人可**伪造**对随机消息x的签名。(s'=m<sup>e</sup>=(s<sup>e</sup>)<sup>e</sup>)

（2）如果消息m1和m2的签名分别为s1和s2，则知道m1 , s1, m2, s2的人可伪造对消息m1m2的签名s1s2 。(**拼接消息**)

（3）在RSA签名方案中，需签名的消息x∈Z<sub>n</sub>，所以每次只能对 (log<sub>2</sub>n)<sub>下取整</sub> 位长的消息进行签名。**签名速度慢**。

**克服缺陷的方法： 签名之前先求消息的Hash值。**

<img src="\Snipaste_2024-05-28_13-25-18.png" style="zoom:80%;" /> 

## 3.ElGamal数字签名体制

签名 :

用户为待签消息m选取秘密随机数k∈Z<sup>*</sup><sub>p-1</sub>,其中g是生成元，y=g<sup>x</sup>，x是私钥，y是公钥

定义Sig(m,k)=(r,s)

**r=g<sup>k</sup> modp**

**s=k<sup>-1</sup>(H(m)-xr)mod(p-1)**

验证：

ver(m,(r,s),y)=true⇔**y<sup>r</sup>r<sup>s</sup>=g<sup>H(m)</sup>modp**

注：k**保密**且是**一次性**的

## 4.数字签名标准（DSS）（了解）

DSS采用了**SHA和DSA**算法

DSA安全性基于求离散对数的困难性

<img src="\Snipaste_2024-05-28_13-28-41.png" style="zoom:80%;" /> <img src="\Snipaste_2024-05-28_13-34-23.png" style="zoom:50%;" /> 预计算:r和k-1

## 5.基于离散对数问题的数字签名体制（了解）

包括ElGamal签名体制、DSA签名体制、Okamoto签名体制、Schnorr签名体制

## 6.SM2椭圆曲线公钥密码签名算法（了解）

## 7.基于大数分解问题的数字签名体制（了解）

### 1.交互式证明

#### 定义：

交互证明系统由两方参与

证明者P （prover）

验证者V （verifier）

P知道某一秘密（如公钥密码体制的秘密钥或一平方剩余x的平方根），P希望使V相信自己的确掌握这一秘密。

#### 零知识证明：

如果V除了知道P能证明某一事实外，不能得到其他任何信息，则称P实现了零知识证明

2.简化的Feige-Fiat-Shamir身份识别方案

3.Feige-Fiat-Shamir身份识别方案

4.Feige-Fiat-Shamir签名体制

## 8.一些特殊的签名（了解）

### 盲签名

盲签名方案是在发送者A和签名者B之间的双方协议。其基本思想如下。A发送给B一段信息，B对它签名并送回A。从这个签名，A能够计算B关于A预先所选消息m的签名。协议完成时，B既不知道消息m也不知道消息的签名。

### 群签名

该方案允许群众的某个成员以群的名义匿名地签发消息。满足下述三个条件：

– 只有群中的成员才能代表群进行签名；

– 签名的接收者能验证签名是哪一个群的一个合法签名，但不能分辨具体的签名者。

– 一旦出现争端，可借助群成员或一个可信的机构能识别出签名者。

# 第七章.密码协议（安全协议）

## 0.概述

### 1）密码协议概述

**协议**是一种有序的过程，每一步必须**依次执行**；需要至少两个或两个以上的参与者，且最终要完成某种任务，即实现某种功能

**密码协议**是建立在密码体制的基础上的一种交互式通信协议，借助于密码算法来达到安全功能

### 2）认证协议概述

认证协议：主要目标是确认某个主体的真实性，确保信息的安全性

#### #认证的分类

#### i.**身份认证**

**身份认证**也称**实体认证**。验证消息发送者所声称的身份，发起通信或访问的实体是否具有合法身份和相应权限

身份认证有两个层次：<u>身份证实和身份识别</u>，二者差别是是否出示身份

<u>身份证实</u>：你是否是你宣称的你，一般的身份认证都是指这种情况

<u>身份识别</u>：我是否知道你是谁

#### ii.**密钥建立认证**

生成、获得加解密密钥

#### iii.**数据源认证**

验证消息与其发送主体的一致性，数据从哪儿来

#### iv.**消息完整性认证**

验证消息是否被篡改

在认证的几个类别里，消息完整性认证是最普通的层次，在前几种认证中一般都包含了消息完整性认证

#### ##数据源认证和消息完整性认证的区别：

**数据源认证**：涉及**通信**，涉及确认消息的**新鲜性**，涉及**消息源**识别

**消息完整性认证**：都不一定涉及

### 3）常见的针对认证和密钥建立协议的攻击

重放攻击 Replay attack

中间人攻击 Man-in-the-middle

已知密钥攻击：从以前用过的密钥确定新密钥

假冒攻击：Impersonation attack

篡改或替换

字典攻击Dictionary attack：

针对口令的一类攻击

并行会话攻击

反射攻击

拒绝服务攻击

### 4）基本认证技术

#### i.证明消息的新鲜性和主体活现性的标准机制---防止重放攻击

**<u>*时间戳*</u>**：如果A收到的消息包括一时戳，且在A看来这一时戳充分接近自己的当前时刻， A才认为收到的消息是新的并接受之。这种方案要求所有各方的时钟是同步的（<u>不适于面向连接的应用</u>）（网络错误，网络延迟，不同步问题）

**<u>*询问应答机制*</u>**：用户A向B发出一个一次性随机数作为询问，如果收到B发来的消息（应答）也包含一正确的一次性随机数，A就认为B发来的消息是新的并接受之。（<u>不适于无连接的应用</u>）（本质特性不符）

#### ii.双向认证和单向认证

#### iii.包含可信第三方的认证

## 1.密钥建立认证协议

A、B两个用户在建立共享密钥时需要考虑的核心问题是<u>***保密性***</u>和<u>***实时性***</u>

### 1）基于对称密钥技术

#### i.NS密钥分配协议(Needham-Schroeder协议)

#### ii.Kerberos认证协议（重点）

使用一个（或一组）独立的**认证服务器（AS）**，来为网络中的用户（C）提供身份认证服务； **用户口令由 AS 保存在数据库中**；**AS 与每个服务器（V）共享一个惟一保密密钥（Kv）**（已被安全分发）。

(1)  C -> AS:   ID<sub>C</sub> || P<sub>C</sub> || ID<sub>v</sub>（用户请求AS服务器，发送自己id、口令、应用服务器id）

(2)  AS -> C:   Ticket（AS服务器返回Ticket）

(3)  C -> V  :   ID<sub>C</sub> || Ticket（用户请求应用服务器，发送自己id、Ticket）

其中：Ticket  =  E<sub>Kv</sub>[ID<sub>C</sub> || AD<sub>C</sub> || ID<sub>v</sub>]

ID<sub>C</sub>：用户C的标识.   ID<sub>v</sub>：服务器标识.

P<sub>C</sub> ：用户口令

AD<sub>C</sub>：用户网络地址

<img src="\Snipaste_2024-05-28_17-06-13.png" style="zoom:60%;" /> 

#####  改进：票据重用（引入票据许可服务器TGS）

<img src="\Snipaste_2024-05-28_17-20-03.png" style="zoom:60%;" /> 

用户发送自己信息(ID,AD,TS)(第一次没有)，服务器返回信息(K,ID<sub>服务器</sub>,Ticket,TS)，都要用它们间的密钥加密

(c<->AS:K<sub>c</sub>,c<->TGS:K<sub>c,TGS</sub>,c<->V:K<sub>c,V</sub>)

### 2）基于公钥加密的密钥分配协议

#### i.简单分配

<img src="\Snipaste_2024-05-28_15-29-42.png" style="zoom:60%;" /> 

① A产生自己的一对密钥{PK<sub>A</sub>,SK<sub>A</sub>}，并向B**发送PK<sub>A</sub>||ID<sub>A</sub>**，其中ID<sub>A</sub>表示A的身份

② B产生**会话密钥K<sub>S</sub>**，并用A的公开钥PK<sub>A</sub>**对K<sub>S</sub>加密后发送**给A

③ A由D<sub>SK<sub>A</sub></sub>[E<sub>PK<sub>A</sub></sub>[K<sub>S</sub>]]恢复会话密钥K<sub>S</sub>。因为只有A能解读K<sub>S</sub>，所以仅A、B知道这一共享密钥。

④ A销毁{PK<sub>A</sub>,SK<sub>A</sub>}，B销毁PK<sub>A</sub>。

##### 安全性：

由于A、B双方在通信前和完成通信后，都未存储密钥，**密钥泄露的危险性为最小**（可防被动攻击）

但由于公钥缺少证书管理机构认证且非物理传输容**易受到主动攻击**：中间人攻击（不可防主动攻击）

<img src="\Snipaste_2024-05-28_15-50-33.png" style="zoom:60%;" /> 

##### 实例：Diffie-Hellman密钥交换原理（重点）

<img src="\Snipaste_2024-05-28_15-53-52.png" style="zoom:60%;" /> <img src="\Snipaste_2024-05-28_15-57-52.png" style="zoom:50%;" /> 

#### ii.具有保密性和认证性的密钥分配

既可防止被动攻击，又可防止主动攻击

<img src="\Snipaste_2024-05-28_16-00-39.png" style="zoom:60%;" /> 每次发送给对方时都先拿对方公钥加密，还要表明自己身份

假定A、B双方**<u>*已完成公钥交换*</u>**(<u>攻击者不知道公钥</u>)，可按以下步骤建立共享会话密钥：

① A用PK<sub>B</sub>的公开钥加密A的身份ID<sub>A</sub>和一个一次性随机数N<sub>1</sub>后发往B，其中N<sub>1</sub>用于惟一地标识这一业务

② B用PK<sub>A</sub>加密N<sub>1</sub>和B新产生的一次性随机数N<sub>2</sub>后发往A。B发来的消息中N<sub>1</sub>的存在可使A相信对方的确是B

③ A选一**会话密钥K<sub>S</sub>**，然后将M=E<sub>PK<sub>B</sub></sub>[E<sub>SK<sub>A</sub></sub>[K<sub>S</sub>||N<sub>2</sub>]]发给B，其中用**B的公开钥加密是为保证只有B能解读加密结果**，用**A的秘密钥加密是保证该加密结果只有A能发送**

④ B以D<sub>PK<sub>A</sub></sub>[D<sub>SK<sub>B</sub></sub>[M]]恢复会话密钥K<sub>S</sub>

## 2.秘密共享

秘密s被分为n个部分,每个部分称为shadow,由一个参与者持有，使得由**k个或多于k个参与者所持有的部分信息可重构s**。由少于k个参与者所持有的部分信息则无法重构s。称为**(k,n)秘密分割门限方案**，k称为**门限值**。

少于k个参与者所持有的部分信息**得不到s的任何信息**称该门限方案是**完善**的。

门限方案由**份额分配算法**和**恢复算法**构成

### 1）Shamir门限方案（重点）

基于多项式的Lagrange插值公式

在有限域GF(q)上的Shamir秘密分割门限方案

（1）秘密的分割

设GF(q)是一有限域，其中q是一个大素数，满足q>=n＋1
**秘密s**是在GF(q)\\{0}上**均匀选取的一个随机数**，表示为s∈<sub>R</sub>GF(q)\\{0}
令**s等于常系数a<sub>0</sub>**
其它k-1个系数**a<sub>1</sub>,a<sub>2</sub>,…,a<sub>k-1</sub>的选取也满足**a<sub>i</sub>∈<sub>R</sub>GF(q)\{0} (i=1,…,k-1)
在GF(q)上构造一个k-1次多项式**f(x)＝a<sub>0</sub>+a<sub>1</sub>x+…+a<sub>k-1</sub>x<sup>k-1</sup>**
n个参与者记为P<sub>1</sub>,P<sub>2</sub>,…,P<sub>n</sub>，其中Pi分配到的子**密钥为（i, f(i)）**

(2) 秘密的恢复

如果任意k个参与者P<sub>i1</sub>,P<sub>i2</sub>,…,P<sub>ik</sub> (1<=i1<i2<…<ik<=n)要想得到秘密s，可计算

<img src="\Snipaste_2024-05-28_19-06-51.png" style="zoom:60%;" /> 

例题：

<img src="\Snipaste_2024-05-28_19-24-08.png" style="zoom:60%;" /> 

<img src="\Snipaste_2024-05-28_19-24-14.png" style="zoom:60%;" /> f(x<sub>1</sub>)=y<sub>1</sub>,f(x<sub>2</sub>)=y<sub>2</sub>,f(x<sub>3</sub>)=y<sub>3</sub>->y1*<sup>(x-x2)(x-x3)</sup>/<sub>(x1-x2)(x1-x3)</sub>

<img src="\Snipaste_2024-05-28_19-24-23.png" style="zoom:60%;" /> 

### 2）基于中国剩余定理的门限方案

### 3）Feldman可验证秘密分享

## 3.基于口令的认证

通过**用户ID和口令**进行认证是操作系统或应用程序通常采用的。（<u>账户+密码</u>）

### 1）口令认证的攻击类型

网络数据流窃听：攻击者通过窃听网络数据，如果口令使用明文传输，则可被非法截获。

认证信息截取/重放

字典攻击：使用字典中的单词来尝试用户的密码

穷举攻击

窥探：安装监视器或亲自窥探合法用户输入口令的过程

社交工程：冒充是处长或局长骗取管理员信任得到口令等

垃圾搜索：搜索被攻击者的废弃物

### 2）加强口令的安全性的措施

（1）在创建口令时执行检查功能。如检查口令的长度，大小写组合，特殊字符。

（2）强制使口令**周期性过期**。也就是定期更换口令。

（3）保持口令历史记录，使用户**不能循环使用旧口令**。

### 3）口令认证协议

#### i.Needham口令认证协议

主机存储**用户名IDu**及其**口令Pwd的hash值**(或单向函数值)
登陆时，首先用户**提交身份IDu**，然后主机提示**输入口令**，用户根据提示输入口令Pwd，主机**验证其hash值是否等于事先存储的hash值**

#### ii.一次口令认证协议S/KEY（重点）

每次发送的口令**<u>*不一样*</u>**，同时为了多次登陆，这些口令应该能由一个口令导出，即它们是**<u>*相关的*</u>**

##### Lamport的一次口令方案

主机H存储初始口令为(ID<sub>u</sub>, hash<sup>n</sup>(Pwd)，n)，U记住Pwd，H中当前口令记录是(ID<sub>u</sub>, hash<sup>c</sup>(Pwd)，c)，其中c大于等于1且小于等于n.登陆时首先提交身份Idu，H提示U输入口令；U计算hash<sup>c-1</sup>(Pwd)发给H，h计算一次hash并检查当前口令是否满足hash<sup>c</sup>；H更新U的当前口令记录为(Idu, hash<sup>c-1</sup>(Pwd)，c-1)其中n和c用于同步，以免受到攻击

 <img src="\Snipaste_2024-05-28_20-08-20.png" style="zoom:80%;" /> 

##### 不确定口令的方法： 

###### ①口令序列

<img src="\Snipaste_2024-05-28_20-00-04.png" style="zoom:60%;" /> 

###### ②挑战/回答

<img src="\Snipaste_2024-05-28_19-59-58.png" style="zoom:60%;" /> 

###### ③时间戳

以用户登录时间作为随机因素，如：
用户计算，登录口令=hash(用户名＋口令 ＋时间）
系统验证， hash(用户名＋口令 ＋时间）