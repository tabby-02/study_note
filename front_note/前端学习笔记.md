# （一）HTML（超文本标记语言）

## 1.基本结构

\<!DOCTYPE html> 声明为 HTML5 文档
\<html> 元素是 HTML 页面的**根元素**
\<head> 元素包含了文档的元（meta）数据，如 \<meta charset="utf-8"> 定义网页编码格式为 utf-8
\<title> 元素描述了文档的标题
\<body> 元素包含了可见的页面内容
\<h1> 元素定义一个大标题
\<p> 元素定义一个段落

## 2.标签（元素）

### 1.\<br>换行（空标签）

### 2.文本格式化

\<b> 	定义粗体文本
\<em> 	定义着重文字
\<i> 	定义斜体字
\<small> 	定义小号字
\<strong> 	定义加重语气
\<sub> 	定义下标字
\<sup> 	定义上标字
\<ins> 	定义插入字
\<del> 	定义删除字

### 3.链接

(1)\<a href="url">**链接**文本\</a>

(2)\<a href="url">\<img decoding="async" src="example.jpg" alt="示例**图片**">\</a>

(3)\<a name="section2">\</a>

\<a href="#section2">**跳转**到第二部分\</a>

(4)\<a href="document.pdf" download>**下载文档**\</a>

#### 属性

1.href：指定链接目标的URL，这是链接的最重要属性。可以是另一个网页的URL、文件的URL或其他资源的URL。    

2.target（可选）：指定链接如何在浏览器中打开。常见的值包括 _blank（在新标签或窗口中打开链接）和 _self（在当前标签或窗口中打开链接）。也可指定一个name属性的值，例target="iframe_a"，其中iframe_a是一个iframe的name属性。

3.title（可选）：提供链接的额外信息，通常在鼠标悬停在链接上时显示为工具提示。

4.rel（可选）：指定与链接目标的关系，如 nofollow、noopener 等。

5.id(可选)：用于创建一个 HTML 文档书签，书签不会以任何特殊方式显示。

例：\<a **href**="网址" **target**="_blank" **rel**="noopener noreferrer">链接文本\</a>

*要始终将正斜杠添加到**子文件夹**。不是href="https://www.123.com/html"而是href="https://www.123.com/html/"

id例：\<a id="tips">提示\</a>

再用跳转访问\<a href="#tips">访问提示\</a>或\<a href="https://www123.com#tips">访问提示\</a>

### 4.头部\<head>

可以添加在头部区域的元素标签为: \<title>, **\<style>**,  \<meta>, \<link>,   **\<script>**, \<noscript> 和 \<base>

\<head> 	定义了文档的信息
\<title> 	定义了文档的标题
\<base> 	定义了页面链接标签的默认链接地址
\<link> 	定义了一个文档和外部资源之间的关系
\<meta> 	定义了HTML文档中的元数据
**\<script>** 	定义了客户端的脚本文件
**\<style>** 	定义了HTML文档的样式文件

### 5.CSS创建（对同一元素定义多种样式时，后定义的会覆盖先定义的）

#### 1.(属性)内联样式css(个别元素)

\<p style="color:red;margin-left:20px;">**段落的颜色和左外边距**\</p>

\<p style="background-color:green;">**背景色**\</p>

\<p style="font-family:arial;color:red;font-size:20px;">font-family（**字体**），color（**颜色**），和font-size（**字体大小**）\</p>

\<p style="text-align:center;"> text-align（**文字对齐**）属性指定文本的水平与垂直对齐方式\</p>

#### 2.(标签)内部样式表css(单个文件)(定义文本样式)

\<head>
\<style type="text/css">
body {background-color:yellow;}
p {color:blue;}
\</style>
\</head>

#### 3.(标签)外部样式表(很多页面)(定义资源引用地址)

\<head>
\<link rel="stylesheet" type="text/css" href="mystyle.css">
\</head>

### 6.\<img>(空标签)

#### 属性：

#### （1）源属性（src）定义图片来源

#### （2）alt 属性用来为图像定义一串预备的可替换的文本

#### （3）height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。

\<img src="url" alt="替换文本" width="111" height="111">

### 7.表格\<table>

#### 结构标签

\<thead>:用于定义表格的标题部分(可无)
\<tbody>:用于定义表格的主体部分(可无)
\<tr>：tr 是 table row 的缩写，表示表格的**一行**。
\<td>：td 是 table data 的缩写，表示表格的数据**单元格**。
\<th>：th 是 table header的缩写，表示表格的**表头单元格**。

例子：

\<table>
  **\<thead>**
    \<tr>
      \<th>列标题1\</th>
      \<th>列标题2\</th>
      \<th>列标题3\</th>
    \</tr>
  **\</thead>**
  **\<tbody>**
    \<tr>
      \<td>行1，列1\</td>
      \<td>行1，列2\</td>
      \<td>行1，列3\</td>
    \</tr>
    \<tr>
      \<td>行2，列1\</td>
      \<td>行2，列2\</td>
      \<td>行2，列3\</td>
    \</tr>
  **\</tbody>**
\</table>

#### 属性

（1）border:边界

\<table border="1">

（2）colspan:跨列

（3）rowspan:跨行

\<th colspan="2">巴拉巴拉\<th/>

### 8.列表

#### 无序列表：粗体原点在表头

\<ul> 	定义无序列表
\<li> 	定义列表项

例：

\<ul>
\<li>列表元素1\</li>
\<li>列表元素2\</li>
\</ul>

#### 有序列表：数字作表头

\<ol> 	定义有序列表
\<li> 	定义列表项

#### 自定义列表：

\<dl> 	定义列表
\<dt> 	自定义列表项目
\<dd> 	定义自定列表项的描述

例：

\<dl>
\<dt>大列表元素1\</dt>
\<dd>小列表元素1\</dd>
\<dt>大列表元素2\</dt>
\<dd>小列表元素1\</dd>
\</dl>

#### 嵌套列表

\<ul>
  \<li>Coffee\</li>
  \<li>Tea
    **\<ul>**
      **\<li>Black tea\</li>**
      **\<li>Green tea\</li>**
    **\</ul>**
  \</li>
  \<li>Milk\</li>
\</ul>

### 9.区块

**块级元素**在浏览器显示时，通常会以新行来开始（和结束）。占用了全部宽度。

实例: **\<div>**\<h1>, \<p>, \<ul>, \<table> 

**内联元素**在显示时通常不会以新行开始。只需要必要的宽度。

实例:**\<span>** \<b>, \<td>, \<a>, \<img>

### 10.布局

用\<div>或\<table>

(可利用float漂浮左右)

### 11.表单和输入

#### 基本格式

\<form action="发送数据的地方" (method="get/post")>------------------------不写method 默认为 GET
input 元素或其他元素
\</form>

#### \<input>标签

\<input type="**text**" name="" value="文本框内初始语句">---------文本域

\<input type="**password**" name="" >-密码字段(不会明文显示)

\<input type="**radio**" name="" value="">----单选按钮

\<input type="**checkbox**" name="" value="">-复选框

\<input type="**submit**" value="按钮上的字">--提交按钮                      \<input type="reset" value="按钮上的字">--重置按钮

\<input type="**button**" value="按钮上的字">--按钮（属性）----还有专门的\<button>\</button>标签，区别在于标签功能更为强大，可以type=button/submit，而且button可以设置点击事件（onclick）

#### 属性

**post**：指的是 HTTP POST 方法，表单数据会包含在表单体内然后发送给服务器，用于提交敏感数据，如用户名与密码等。      

**get**：默认值，指的是 HTTP GET 方法，表单数据会附加在 action 属性的 URL 中，并以 **?**作为分隔符，一般用于不敏感信息，如分页等。

#### 其他标签

##### 1.\<label> :

内定义了 \<input> ，一般为输入标题

\<form>
  \<label>Name:
    \<input .....>
  \</label>
\</form>

##### 2.\<select>\<option>:下拉（输入）菜单

\<form action="">
\<**select** name="">
\<**option** value="">下拉选项名**\</option>**
\<option value="">下拉选项名\</option>
\<option value="">下拉选项名\</option>
\<option value="">下拉选项名\</option>
**\</select>**
\</form>

##### 3.\<textarea>:文本域

\<textarea rows="" cols="">
文本框内初始语句
\</textarea>

##### 4.\<fieldset>:表单

\<form action="">
\<fieldset>
\<legend>位于表框上的字\</legend>
表内部分
\</fieldset>

### 12.框架\<iframe>

框架内显示来源url的页面

\<iframe src="来源url" width="" height="" frameborder="">
\</iframe>

### 13.脚本\<script>-----javascript

（\<noscript>提供不支持脚本时的替代内容，其只会在不支持脚本时才显现，一般输出报错文本）

## 3.颜色表示

#### 1.名称

\<p style="background-color:yellow">

#### 2.rgb

\<p style="background-color:rgb(255,255,0)">(值0-255)------扩展：rgba,新增a为透明度(0-1)

#### 3.16进制

\<p style="background-color:#FFFF00">(值00-FF)(也可以是三位#000,#0F0.....其中0-0,F-255,8-136)

## 4.字符实体

HTML 中的预留字符(<,>,空格(无论多少空格都会只剩一个),结合音标符)必须被替换为字符实体(&name;或&#number; )。

空格 	\&nbsp;

小于号 	\&lt;

大于号 	\&gt;

和号 	\&amp;

引号 	\&quot;

撇号  	\&apos; (IE不支持)

à	a\&#768;

á	a\&#769;

## 5.URL

 scheme://host.domain:port/path/filename  

说明:         

scheme - 定义因特网服务的类型。最常见的类型是 http         

host - 定义域主机（http 的默认主机是 www）        

domain - 定义因特网域名，比如 runoob.com         

:port - 定义主机上的端口号（http 的默认端口号是 80）        

path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。

# （二）CSS（层叠样式表）

## 1.选择器

### (0)优先级

优先级关系：!important>内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 元素选择器 = 伪元素选择器

### (1)元素（伪元素）选择器

如下代码，p 选择器将选择所有 \<p> 元素:

p {
  color: blue;
}

### (2)类（伪类）选择器，（.）可引用多次

类选择器以 . 开头(.前可以有元素)，后面跟着类别名称 

**一对多：class="A B"对应 .A{}  .B{}两个选择器**

### (3)ID 选择器，（#）只可引用一次

ID 选择器以 # 开头，后面跟着 ID 名称

### (4)属性选择器（元素1的属性1------>(修改)所有属性为属性1的元素1）

 如下代码，input[type="text"] 选择器将选择所有 type 属性为 "text" 的 \<input> 元素。

(元素)[属性(=....)]{}

input[type="text"] {
  border: 1px solid gray;
}

=可以换成多值，多值~=, |=, ^=, $=, *= 的区别 

要求含有完整单词的比较符号: ~=(包含), |= (开头)            

要求含有能从字符串中拆分出来的比较符号: *=(包含), ^=(开头), $=(结尾)

要求完全一致的比较符号：=

### (5)后代选择器（元素1    元素2------>(修改)所有元素1的所有下级元素）

后代选择器使用**空格**分隔元素名称

元素 元素{}

如下代码，div p 选择器将选择所有在 \<div> 元素内的 \<p> 元素。

div p {
  font-weight: bold;
}

### (6)子元素选择器（元素1>元素2------>(修改)所有元素1的下一级元素）

### (7)相邻兄弟选择器（元素1+元素2------->(修改)所有元素1的第一个兄弟元素）

**二者有相同父元素**。

### (8)后续兄弟选择器（元素1~元素2------->(修改)所有元素1的所有兄弟元素）

**二者有相同父元素**。

### (9)通用选择器

选择所有 HTML 元素。通用选择器使用 * 符号。

### (10)分组选择器

同时定义多个选择器，每个选择器用**逗号**分隔。

h1,h2,p
{
    color:green;
}

### (11)嵌套选择器

即前面的选择器**可嵌套**

例：p.classname{}  p1.classname h{}

## 2.听觉样式表

h/p/...
{
    voice-family:male;
    richness:80;
    cue-before:url("beep.au") 

................

}

## 4.动画

### 1.定义关键帧（该处停顿）（style中）

#### 方法一

@keyframes 动画名称
    {
    from { ;}
    to { ;}
    }

/*Safari 和 Chrome:*/
@-webkit-keyframes 动画名称
{
    from {;}
    to {;}
}

#### 方法二

@(-webkit-)keyframes 动画名称
    {
   x% {内为属性（background,border（边界）,bottom（距底部距离）,font（字体）等）}

   y%{}

   }

### 2.将动画应用于元素上

在元素中用(-webkit-)**animation属性**调用动画名称，且可以细化动画

animation-name:slidein;
animation-duration:2s;
animation-timing-function:ease-in-out;
animation-directioin:normal;
animation-fill-mode:forwards;
animation-delay:2s;

或简化为animation:动画名称 或 animation:动画名称 时长 速度 方向 填充模式

animation: name duration timing-function delay iteration-count direction fill-mode play-state;

## 5.函数

### 1.attr() 

attr(属性名)。函数返回选择元素的属性的值(字符串)。

### 2.calc() 

函数用于表示动态长度值。100%表示该元素向外的边框（父元素）的最大容量。

运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)

### 3.hsl()（hsla()）

函数使用色相、饱和度、亮度（透明度）来定义颜色

色相（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。     

饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0-100% 的数值。    

亮度（L） 取 0-100%，增加亮度，颜色会向白色变化；减少亮度，颜色会向黑色变化。    

透明度（A） 取值 0~1 之间， 代表透明度。

#p1 {background-color:hsl(120,100%,50%);} /* 绿色 */

### 4.counter()

counter(计数器名)。函数以**字符串**形式返回当前计数器的值。

#### (1).counter-reset 属性

对部分和子部分进行编号，重置。一般在\<style>内定义。

body {counter-reset:计数器名;}--------在body范围内不重置
h1 {counter-reset:计数器名;}-----------在一个h1范围内不重置，下一个h1重置计数器值

#### (2).counter-increment 属性

h1:before
{
	counter-increment:section;
	content:"Section " counter(section) ". ";
}-------------------------------------------------每次到h1时计数器加一

#### (3).counterstyle(可选)

counter(countername, counterstyle)

counterstyle可选list-style-type 属性

例：lower-roman 	小写罗马数字(i, ii, iii, iv, v, 等)

upper-roman 	大写罗马数字(I, II, III, IV, V, 等)

decimal-leading-zero 	0开头的数字标记。(01, 02, 03, 等)

lower-latin 	小写拉丁字母(a, b, c, d, e, 等。)（字母表示顺序）

#### (4)设置嵌套计数器

##### 1.多计数器法

body {
  counter-reset: section;------------计数器1
}h1 {
  counter-reset: subsection;-------计数器2
}h1::before {
  counter-increment: section;
  content: "Section " counter(section) ". ";
}h2::before {
  counter-increment: subsection;
  content: counter(section) "." counter(subsection) " ";
}

\<body>

\<h1>\</h1>
\<h2>\</h2>
\<h2>\</h2>

\<h1>\</h1>
\<h2>\</h2>
\<h2>\</h2>

##### 2.嵌套法

ol {
  counter-reset: section;
  list-style-type: none;
}li::before {
  counter-increment: section;
  content: counters(section,".") " ";
}

\<ol>
  \<li>item\</li>
  \<li>item   
        \<ol>
            \<li>item\</li>
            \<li>item\</li>
            \<li>item\</li>
       \</ol>
 \</li>
\</ol>

### 5.max(),min()

max(value1, value2, ...)

### 6.rgb(),rgba()

见html颜色

### 7.var()

**用于插入**自定义的属性值，如果一个属性值在**多处被使用**，该方法就很有用。

var(custom-property-name, value)

custom-property-name 	必需。自定义属性的名称，**必需以 -- 开头**。
value 	                           可选。备用值，在属性不存在的时候使用。

例：

\<style>

:root {
  --main-bg-color: coral;
}

#div1 {
  background-color: var(--main-bg-color);
}

\</style>

### 8.repeat()

表示轨道列表(grid属性)（见css3）的重复片段，允许以更紧凑的形式写入大量显示重复模式的列或行

### 9.minmax()

定义了一个长宽范围的闭区间， 它与grid属性一起使用

## 6.伪类，伪元素

 css3明确了单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。但是为了保证兼容性，现在伪元素普遍还是使用单引号。可以多个伪元素

### 1. :before 和 :after

 选择器在被选元素的内容前面插入内容。  使用 content 属性来指定要插入的内容。

#### content有几个比较有用的值：

##### 1.[String] 

使用引号包括一段字符串

元素:after { content: "↗"; }

##### 2. attr() 

 实际上是[String]的一种，调用当attr函数中元素的属性作为字符串，可以方便的比如将图片的 Alt 提示文字或者链接的 Href 地址显示出来。可以伪类加伪元素，例a:hover:before{}

a:after { content:"字符串" attr(href) "字符串"; }/a:after {content: attr(href);}

​                  字符串url字符串                                                      url

##### 3.url() / uri()

用于引用媒体文件

h1::before { content: url(logo.png); }

##### 4.counter()

调用计数器，可以不使用列表元素实现序号功能。

h2:before { **counter-increment**: chapter; **content**: "Chapter " counter(chapter) ". " }

### 2.链接使用伪类

#### a:link - 正常，未访问过的链接    

#### a:visited - 用户已访问过的链接    

#### a:hover - 当用户鼠标放在链接上时    

#### a:active - 链接被点击的那一刻

链接的样式，可以用任何CSS属性

当设置为若干链路状态的样式，也有一些顺序规则：a:hover 必须跟在 a:link 和 a:visited后面    a:active 必须跟在 a:hover后面

伪类可以与 CSS 类配合使用

a.classname:visited {}

### 3.:first-child/last-child

p:first-child{}-------选择所有p中的第一个p

p > i:first-child-----选择所有p的第一个下一级元素i

p>i-------------------选择所有p的下一级元素

p i  ------------------选择所有p的下级元素

### 4.:lang

使你有能力为不同的语言定义特殊的规则

q:lang(no)     \<q lang="no">

q.no              \<q class="no">

### 5.:first-line/:first-letter

用于向文本的首行/字母设置特殊样式。只能用于块级元素。

### 5.其他

#### :root

:root是一个伪类选择器，用于选择HTML文档的根元素。在每个HTML文档中，只有一个根元素，通常是标签。

可以轻松地定义全局样式和变量

:root {
/* 这里的样式将应用于整个文档 */
--main-color: #333;
}

#### :focus 	

input:focus 	选择元素输入后具有的焦点

input:focus
{
	background-color:yellow;
}------------------------------------使选择区域背景为黄色

#### :not(p/.classname)

选择不是p/.classname的元素

## 7.尺寸

### 1.设置元素尺寸的属性

x   y-x   (x=height,width;y=max,min)  line-height(行高)

其中max-height指元素最大高度，文字可超出元素最大高度，而背景不能

### 2.单位

#### 1.相对长度

em 	它是描述相对于应用在当前元素的字体尺寸（例如div中的span中定义的xem就是相对于em元素字体大小(div中定义的长度)）

rem   作用于非根元素（html）时，相对于根元素字体大小；作用于根元素字体大小时，相对于其初始字体(16px)大小。

vw    视窗宽度，1vw=视窗宽度的1%

vh    视窗高度，1vh=视窗高度的1%

vmin/vmax   vw和vh中较小、大的那个。

%   相对于包含块的高宽或字体大小

如果是静态定位和相对定位，包含块一般就是其父元素。

如果是绝对定位的元素，包含块应该是离它最近的 position为非static属性的祖先元素。

如果是固定定位的元素，它的包含块是视口（viewport）。

#### 2.绝对长度

cm 	厘米	
mm 	毫米	
in 	英寸 (1in = 96px = 2.54cm)	
**px 	像素** (1px = 1/96th of 1in)
pt 	point，大约1/72英寸； (1pt = 1/72in)	
pc 	pica，大约 12pt，1/6英寸； (1pc = 12 pt)



## 8.文本的属性

### 1.text-align

文本的对齐方式  center;right;justify;设置为"justify"，每一行被展开为宽度相等，左，右外边距是对齐（如杂志和报纸）。

无vertical-align

### 2.text-decoration

文本修饰  none;overline;line-through;underline;用来去下划线，加下划线

### 3.text-transform

文本转换  uppercase;lowercase;capitalize;可用于所有字句变成大写或小写字母，或每个单词的首字母大写。

### 4.text-indent

文本缩进   用来指定文本的第一行的缩进。

### 5.line-height

行高

## 9.字体的属性

通用字体系列 - 拥有相似外观的字体系统组合（如 "Serif" 或 "Monospace"）     

特定字体系列 - 一个特定的字体系列（如 "Times" 或 "Courier"）

p(.a){font-family:"Times New Roman", Times, serif} （在\<head>中定义,其中.a是class=a的p）

字体族：字体族包括五个类别，分别是"serif"，"sans-serif"，"cursive"，"monospace"和"fantasy"。应该将其放置在字体系列名称列表的最后。

Serif字体中字符在行的末端拥有额外的装饰,"Sans"是指无 - 这些字体在末端没有额外的装饰

### 1.font-family

用font-family:字体1，字体2,字体族 来给浏览器多个字体备选项，前面的不支持就依次后移

### 2.font-style

normal;italic;oblique;    正常 - 正常显示文本, 斜体 - 以斜体字显示的文字,倾斜的文字 - 文字向一边倾斜（和斜体非常类似，但不太支持） italic 是使用文字的斜体，oblique 是让没有斜体属性的文字倾斜！斜体的角度也可以又 oblique 设置：font-style: oblique 5deg

### 3.font-size

### 4.font-weight

设置不同的字体粗细  normal;lighter;bold;

## 10.background及属性

当使用简写属性时，属性值的顺序为：

background:background-color background-image background-repeat background-attachment background-position 

以上属性无需全部使用,各值之间用空格分隔

### 1.bg-attachment

scroll 	背景图片随着页面的滚动而滚动，这是默认的。
**fixed** 	背景图片不会随着页面的滚动而滚动。
local 	背景图片会随着元素内容的滚动而滚动。
initial 	
inherit

### 2.bg-image

 url('URL')

### 3.background-position

格式：x x                       x=left,right,center,x%,top,bottom

### 4.background-repeat

repeat 	背景图像将向垂直和水平方向重复。这是默认
repeat-x 	只有水平位置会重复背景图像
repeat-y 	只有垂直位置会重复背景图像
no-repeat 	background-image 不会重复

### 5.background-size

background-size: *length*|*percentage*|cover|contain;

length 	设置背景图片高度和宽度。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为 auto(自动)
percentage 	将计算相对于背景定位区域的百分比。

cover 	此时会保持图像的纵横比并将图像缩放成将完全覆盖背景定位区域的最小大小。（即使no-repeat也可能repeat）
contain 	此时会保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小。（即使no-repeat也可能repeat）

### 6.background-blend-mode

定义了背景层的混合模式（图片与颜色）

background-blend-mode: normal|multiply|screen|overlay|darken|lighten|color-dodge|saturation|color|luminosity;

normal下放在bg-image前的优先显示，后的被覆盖。

multiply 	正片叠底模式。

overlay 	叠加模式。

### 7.background-clip

指定背景绘制区域。

background-clip: border-box|padding-box|content-box;

### 8.background-origin

background-origin: border-box|padding-box|content-box;

指定background-position属性的起始位置。

padding-box 	背景图像填充框的相对位置（填充框外边界）
border-box 	背景图像边界框的相对位置（外框外边界）
content-box 	背景图像的相对位置的内容框（文本框外边界）

## 11.列表的属性

### 1.list-style-type

指定列表项标记的类型

list-style-type:circle/square/upper-roman/lower-alpha/none;    

none可用于移除默认标记

### 2.list-style-image

使用列表样式图像指定列表项标记

list-style-image: url('sqpurple.gif');

上面的例子在所有浏览器中显示并不相同如果你想在所有的浏览器放置同样的形象标志，就应使用浏览器兼容性解决方案

ul
{
    list-style-type: none;
    padding: 0px;
    margin: 0px;
}
ul li
{
    background-image: url(sqpurple.gif);
    background-repeat: no-repeat;
    background-position: 0px 5px; 
    padding-left: 14px; 
}

### 3.list-style-position

inside 	列表项目标记放置在文本以内，且环绕文本根据标记对齐。
outside 	默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。

### 4.list-style

简写属性

可以按顺序设置如下属性:list-style-type list-style-position list-style-image

## 12.表格的属性

### 1.border

table/th/td/th,td/....
{
    border: 1px solid black;
}

上面的例子中的表格有双边框。这是因为表和th/ td元素有独立的边界。

### 2.border-collapse

设置表格的边框是否被**折叠**成一个单一的边框或隔开

table {
    border-collapse: collapse;
}

### 3. width,height

### 4.文字对齐

text-align：左，右，或中心

vertical-align：顶部，底部或中间

### 5.padding

填充

### 6.color

## 13.盒子的属性

Margin(外边距) - 清除边框外的区域，外边距是透明的。     

outline(轮廓)-是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。

Border(边框) - 围绕在内边距和内容外的边框。     

Padding(内边距) - 清除内容周围的区域，内边距是透明的。     

Content(内容) - 盒子的内容，显示文本和图像。

指定一个 CSS 元素的宽度和高度属性时，你**只是设置内容(content)区域**的宽度和高度。

总元素的宽度=宽度+左填充+右填充+左边框+右边框+左边距+右边距

### 1.margin

该属性可以有1到4个（长度）值。auto为自动居中对齐。

1：上下左右  2：上下，左右  3：上，左右，下  4：上，下，左，右

### 2.outline

x    x-y   (x=ouline,y=color,style,width)

### 3.border

/* 边框宽度 | 边框样式 | 边框颜色 */
border: medium dashed green;

border 	border-style 	border-width 	border-color  border-x  border-x-y(x=bottom,left,right,top;y=color,style,width)

border-radius:50px;    (设置圆角边框，值越大越圆，若设两个值则分别为左上和右下)（可用border-top-left-radius单独指定边角）

### 4.padding

该属性可以有1到4个（长度）值。

1：上下左右  2：上下，左右  3：上，左右，下  4：上，下，左，右

### 5.补充

#### 1.border-style,outline-style可选值

none: 默认无边框

dotted: 定义一个点线边框

dashed: 定义一个虚线边框

solid: 定义实线边框

double: 定义两个边框。 两个边框的宽度和 border-width 的值相同

groove: 定义3D沟槽边框。效果取决于边框的颜色值

ridge: 定义3D脊边框。效果取决于边框的颜色值

inset:定义一个3D的嵌入边框。效果取决于边框的颜色值

outset: 定义一个3D突出边框。 效果取决于边框的颜色值

#### 2.border-width,outline-width可选值

thin 	规定细轮廓。
medium 	默认。规定中等的轮廓。
thick 	规定粗的轮廓。
长度 	允许您规定轮廓粗细的值。

## 14.对齐

### 1.水平居中对齐

元素 margin: auto+width:x%(x!=100)    利用自动元素外边距来居中（图片也是 margin: auto）

文本 text-align: center

### 2.左右对齐

#### (1)使用定位方式

position: absolute+right: 0px;   (当使用 position 来对齐元素时, 通常 <body> 元素会设置 margin 和 padding 。 这样可以避免在不同的浏览器中出现可见的差异。)

#### (2)使用 float 方式

### 3.垂直居中对齐

#### (1)用padding

padding: 70px 0;    只用两位，70px为上下距，0为左右距（利用垂直总高小于140的间距扩展来居中，若大于140则不管用）

#### (2)用line-height

设置line-height=height来居中（行高含义为一行加上下距高之和）

### (3)用transform属性设置

position设置为absolute

top,left设置为50%----------------------------------------------------------------------放置元素（50%相对于父元素）

transform: translate(-50%, -50%);    （移动元素）----------------------------调整元素（50%相对于本元素）

原理：top和left设置的50%是元素的上边界和左边界距外边界为总长的50%，要加上元素自身宽和高的一般才位于正中

## 15.其他属性

### 1.**display，visibility

#### 1.隐藏元素

visibility:hidden;隐藏的元素仍需占用与未隐藏之前一样的空间。

display:none;隐藏的元素不会占用任何空间。

#### 2.改变块，内联元素显示

display:inline;将块变为内联

display:block;将内联变为块

### 2.position

指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型。

absolute 	生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。  例：p{position:absolute}中父元素就为p

relative 	生成相对定位的元素，相对于其正常位置进行定位。

static 	默认值。即没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。

fixed    元素的位置相对于浏览器窗口是固定位置。即使窗口是滚动的它也不会移动，使元素的位置与文档流无关，因此**不占据空间。**

sticky   粘性定位的元素是依赖于用户的滚动，在 **position:relative 与 position:fixed 定位之间切换**。表现为在跨越特定阈值前为相对定位，之后为固定定位。指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。

#### z-index

元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素。z-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）。一个元素可以有正数或负数的堆叠顺序。如果两个定位元素重叠，没有指定z - index，最后定位在HTML代码中的元素将被显示在最前面。

### 3.bottom,left,top,right

设置左（上,下）边缘位置

对于绝对定位元素(position:absolute;)，bottom属性设置单位**高于(正)**/低于(负)**包含它的元素的底边**。

对于相对定位元素(position:relative;)，bottom属性设置单位高于/低于**其正常位置**的元素**的底边**。

注意：如果"position：static"，底部的属性没有任何效果。

### 4.overflow

设置溢出内容显示方式

visible 	默认值。内容不会被修剪，会呈现在元素框之外。
hidden    内容会被修剪
scroll 	内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。
auto 	如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。

### 5.浮动

#### 1.float

元素只能左右移动而不能上下移动。浮动元素之后的元素将围绕它。浮动元素之前的元素将不会受到影响。**如果你把几个浮动的元素放到一起，如果有空间的话，它们将彼此相邻。**

#### 2.clear

指定段落的左侧或右侧不允许浮动的元素：

left 	在左侧不允许浮动元素。
right 	在右侧不允许浮动元素。
both 	在左右两侧均不允许浮动元素。

clear属性会让元素下移至浮动元素之下

### 6.cursor

光标在元素上的显示形式

### 7.align-content/justify-content

在弹性容器内的各项没有占用所有可用的空间时对齐容器内的各项（垂直）(水平)

align-content: stretch|center|flex-start|flex-end|space-between|space-around|initial|inherit;

stretch 各行将会伸展以占用剩余的空间。

center 各行向弹性盒容器的中间位置堆叠。（紧挨）

flex-start 各行向弹性盒容器的起始位置堆叠。（紧挨）

flex-end 各行向弹性盒容器的结束位置堆叠。（紧挨）

space-between 各行之间留有空白。（开始结尾紧挨边界）

space-around 各行之前、之间、之后都留有空白。（开始结尾不紧挨边界）



### 8.align-items

定义**flex**子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。

align-items: stretch|center|flex-start|flex-end|baseline|initial|inherit;

### 9.align-self

定义**flex**子项单独在侧轴（纵轴）方向上的对齐方式。

### 10.all

修改所有该元素或其父元素的属性为初始值、父值

all: initial|inherit|unset;

unset 	修改所有元素属性为其父元素的值(如果有继承则优先)或其初始值

### 11.box-pack,box-align(css3)

指定box的子元素如何对齐。

### 

### 12.caption-side

设置表格标题的位置。

caption-side:top/bottom;

## 16.导航栏设置

导航栏=链接列表

使用无序列表\<ul>\<li>

1.删除边距和填充：list-style-type: none; margin: 0; padding: 0;

2.建立一个垂直的导航栏display:block(对li a);

3.建立一个横向导航栏 display:inline(对li);/float:left;display:block(li a);

3.使用:hover伪类,.active类

4.全屏高度的固定导航条:position: fixed;height: 100%;

## 17.下拉（显示链接）菜单

鼠标移动到指定元素上时，会出现**下拉菜单**

.dropdown {
  position: relative;
  display:  inline-block;
}

.dropbtn {------------------------------------------------------设置按钮样式

}

.dropdown-content {
  display: none;-------------------------------------------------隐藏下拉菜单且不占空间
  position: absolute;-------------------------------------------使下拉菜单显示时不会将之后的元素挤开
  background-color: #f9f9f9;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  padding: 12px 16px;
}
.dropdown:hover .dropdown-content {----------------------------在鼠标悬停在.dropdown上时显示.dropdown-content内容
  display: block;
}

.dropdown-content a:hover {background-color: #f1f1f1}-------鼠标移上去后修改下拉菜单链接颜色

.dropdown:hover .dropbtn {
    background-color: #3e8e41;
}---------------------------------------------------------------------------当下拉内容显示后修改下拉按钮的背景颜色

\<div class="dropdown">
  \<button class="dropbtn">下拉菜单\</button>
  \<div class="dropdown-content" (style="left:0")>------------style设置对齐方式，例为距父bottom左边界0（元素嵌套后子元素定位是相对于其父元素，父元素在未设置大小时大小为其包含内容的大小）
    \<a href="#">\</a>
    \<a href="#">\</a>
    \<a href="#">\</a>
  \</div>
\</div>

## 18.提示工具

### 1.基本与下拉菜单相似，只用注意定位

显示在右、左侧：
.tooltip .tooltiptext {
    top: -5px;
    left/gright: 105%; 
}

显示在上、下侧与左右类似，但如果要在正中

bottom: 100%;
left: 50%;
margin-left: -60px;-------其中60px为提示文本的一半宽

或者

bottom: 100%;
left: calc(50% - 60px);   （不要忘了两空格）

### 2.添加箭头

.tooltip .tooltiptext::after {
    content: " ";---------------------------------------内容设空
    position: absolute;
    bottom: 100%; 
    left: 50%;
    margin-left: -5px;------------------------------------------定位，其中5px来于下面的5px，也仍可以简化为calc()来定位
    border-width: 5px;-----------------------------------------设置箭头大小
    border-style: solid;
    border-color: transparent transparent black transparent;--------------利用三透明一有色来绘制箭头
}

### 3.淡入效果（css3）

.tooltip .tooltiptext {
    opacity: 0;---------------------透明度（0.0-1.0）
    transition: opacity 1s;
}

.tooltip:hover .tooltiptext {
    opacity: 1;
}

## 19.图片廊

多个

\<div class="">
  \<div class="img">
    \<a target="_blank" href="URL">
      \<img decoding="async" fetchpriority="high" src="URL" alt="图片文本描述" width="300" height="200">
    \</a>
    \<div >图片描述\</div>
  \</div>
\</div>

## 20.图像拼合

利用background

图形会自动重复排布，故设置背景大小来截取，背景position来定位截取位置

### 1.利用一个小的透明图像

img.classname {
    width: 46px;
    height: 44px;---------------------------------------------截取大小
    background: url(**真正的图片URL**)     0 0;-------------定位截取位置
}
\<img class="classname" src="一个小的透明图像的URL">

### 2.利用链接背景

a{ display:block;}-----------------------------将链接转为块
.classname{    height:44px;   width:46px;   background:url(图片URL)        0 0;       }-----同1
.classname:hover{                              background: url(图片URL)       0 -45px;}-----悬停图片
\<a class="classname" href="链接到的URL">\</a>

## 21.媒体类型选择器

@media x   {

}------------------------------(x=媒体类型)

**all** 	用于所有的媒体设备。
aural 	用于语音和音频合成器。
braille 	用于盲人用点字法触觉回馈设备。
embossed 	用于分页的盲人用点字法打印机。
handheld 	用于小的手持的设备。
**print** 	用于打印机。
projection 	用于方案展示，比如幻灯片。
**screen** 	用于电脑显示器。
tty 	用于使用固定密度字母栅格的媒体，比如电传打字机和终端。
**tv** 	用于电视机类型的设备。

## 22.表单和输入样式

1.设置外观     width 属性  padding 属性  border 属性  background-color 属性background-image 属性background-position 属性

2.设置未输入时提示      \<input  type="text" placeholder="搜索..">

3.设置聚焦时外观     :focus 选择器

4.设置动画    transition 属性-----------------聚焦时将输入框变长

input[type=text] {
  (-webkit-)transition: width 0.4s ease-in-out;-------(css3)transition: property duration (timing-function) (delay);
}                                                                                                   css属性   指定完成用时s/ms   转速曲线   效果开始的时候

input[type=text]:focus {
  width: 100%;
}

5.使用 resize 属性来禁用文本框(\<textarea>)可以重置大小的功能（一般拖动右下角可以重置大小）。 

6.响应式表单 可以根据浏览器窗口的大小重新布局各个元素

## 23.布局

头部区域、菜单导航区域、内容区域、底部区域。

### /* 列后清除浮动 */

**.row**:after {
  content: "";
  display: table;
  clear: both;
}

### 整体

\<body>

\<div class="header">-----------------------------------------头部区域

  \<h1>头部区域\</h1>

\</div>

\<div class="topnav">------------------------------------------菜单导航
  \<a href="#">链接\</a>
  \<a href="#">链接\</a>
  \<a href="#">链接\</a>
\</div>

\<div class="**row**">----------------------------------------------列
  \<div class="column side">---------------------------------列1
    \<h2>左侧栏\</h2>
    \<p>\</p>
  \</div>

  \<div class="column middle">------------------------------列2
    \<h2>主区域内容\</h2>
    \<p>\</p>
  \</div>

  \<div class="column side">---------------------------------列3
    \<h2>右侧栏\</h2>
    \<p>\</p>
  \</div>

\</div>

\<div class="footer">--------------------------------------------底部
  \<p>底部区域\</p>
\</div>

\</body>

### 响应式布局

/* 响应式布局 - 屏幕尺寸小于 800px 时，两列布局改为上下布局 */
@media screen and (max-width: 800px) {
  .leftcolumn, .rightcolumn {   
    width: 100%;
    padding: 0;
  }
}

## 24.!important

用于增加样式的权重。使用一个 !important 规则时，此声明将覆盖任何其他声明。

一定要优先考虑使用样式规则的优先级来解决问题而不是 !important
只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important

.button {
  background-color: #8c8c8c !important;
  color: white !important;
  padding: 5px !important;
  border: 1px solid black !important;
}

# （三）JavaScript 

## 1.用法

### 1.在 \<head> 或者 \<body> 的\<script>\</script>之间

### 2.外部的 JavaScript

\<script src="myScript.js">\</script>

### 3.事件触发时

\<html元素 事件='JavaScript 代码'>---------------------------单引号双引号都可用

#### 常见事件：

1.onchange 	HTML 元素改变
2.onclick 	用户点击 HTML 元素
3.onmouseover 	  鼠标移入     onmouseout    鼠标移出
4.onmousedown 	点击鼠标     onmouseup     松开鼠标 
5.onkeydown 	用户按下键盘按键
6.onload 	浏览器已完成页面的加载     onunload   用户离开界面
7.onfocus   输入字段获得焦点

## 2.输出

### 1.window.alert()

弹出警告框。

### 2.**document.write()** 

写到 HTML 文档中。

如果在文档已完成加载后(例如点击事件)执行 document.write，**整个** HTML 页面将被覆盖。

### 3.innerHTML属性

写到 HTML 元素。

1.\<script>document.getElementById("idname").innerHTML = "XX"\</script>;------查找并修改id元素

2.\<XX onclick="getElementById("idname").innerHTML=XX">

3.\<XX onclick="this.innerHTML=XX">;-----------------------------------------------     修改本元素

### 4.**console.log()** 

写到浏览器的控制台。

调试模式(F12)调试菜单(console)

### 5.改变 HTML 元素的属性值

document.getElementById("idname").html元素**属性** = "新**属性值**"-------例：.src="XX.jpg"

扩展：document.getElementById("idname").onclick="XX"--------通过JS给html分配事件

## 3.数据类型

都用**var定义**，拥有**动态类型**。这意味着相同的变量可用作不同的类型。

### 1.基本类型

#### 1.number

JavaScript **只有一种数字类型**。数字可以带小数点，也可以不带---------小数的number也是用浮点数表示的，存在估算问题

#### 2.字符串

​	1.**单引号，双引号都可以用**

​	2.字符串内也可以有引号，但不能和最外面的匹配,也可用  **\\ "**  来防止错误

​	3.访问字符串的字符   arrayname[x]

​	4.字符串的属性和方法（字符串是基本类型，但执行属性和方法时会将它当做对象）----------------------**原理：后台会自动创建对象，调用后再销毁对象（string,number,boolean都是）**

​		arrayname.length

​	5.模版字符串(用反引号包围)

​     \`a`==="a"          -----------------------支持多行且不需  \  

​	  可包含变量，**JS表达式**在**$( )中**，**外**可包含普通字符串，**html表达式**

​	6."+"可进行字符串拼接

​			字符串+数字=字符串

#### 3.boolean

true 或 false

#### 4.null,undefined

1.var person = null;               // 值为 null(空), 但**类型**为**对象**

var person = undefined;   // 值为 undefined,     **类型**为 **undefined**

2.*null 和 undefined 的值相等，但类型不等

null === undefined           // false
null == undefined            // true

3.判断一个变量是否有值（非null,undefined）

if (     **typeof** myObj !== "undefined"   &&   myObj !== null   )---------------未定义的值不能用来比较，故用typeof来判断。同时要先判断是否有定义再判断是否为空，不然可能报错

### 2.对象类型

#### 1.数组声明

##### 法1.实例化

(1).var arr1=new Array();
arr1[0]="Saab";
arr1[1]="Volvo";
arr1[2]="BMW";

(2).var arr2 = new Array(2);-----------------------------------------规定了数组的长度为2  
arr2[0] = "ddd";  
arr2[1] = "www";  

(3).var arr3=**new Array(**"Saab","Volvo","BMW"**)**;---------声明时赋值

##### **法2**.常用

var arr4 = [false,"aaa",123]; 

#### 2.对象声明

##### 法1：常用

var person=**{**firstname**:**"John", lastname**:**"Doe", id**:**5566**}**;------------对象可以包含多个值（多个变量），每个值以 name**:**value 对呈现。

##### 法2：实例化 

var person=new Object();	

person.firstname="John";

##### 法3：声明函数

function Person(firstname){

this.firstname=name;

}

var person=new Person("John");--------------------实例化

##### 1.访问对象属性

法1.name=person.lastname;
法2.name=person["lastname"]; 

##### 2.访问对象方法

objectName.methodName()---------------------不加()会返回函数的定义

#### 3.window对象

**所有的变量**都是window对象的属性

## 4.变量

var  name =new  类型;

### 变量的生存期

#### 1.var

JavaScript 变量的生命期从它们被声明的时间开始。（var有声明提升）

局部变量会在函数运行以后被删除。-----------函数中的变量

全局变量(属于window对象)会在页面关闭后被删除。------------函数外的变量（注意：**代码块中的变量也算全局变量**）

##### 注意：

1.不同于其他语言，**不可**一语句多变量**赋同一值**（var x,y,z=1;错误）

2.**重声明**不丢失值（var carname="Volvo";  var carname;）--------但**重赋值**还是会覆盖

3.非严格模式下**给未声明变量赋值**创建的是全局变量(即使在函数中)，该变量将被自动作为window对象的一个属性，可以删除(delete)。

#### 2.let

1.let 关键字实现**块级作用域**。let 声明的变量只在 let 命令所在的**代码块 {} 内有效，在 {} 之外不能访问**

2.let声明的全局变量不属于window对象

3.let**不能重赋值**(let->let,let->var,var->let)

4.无声明提升，必须先声明再使用

#### 3.const

1.声明一个或多个常量，声明时**必须进行初始化**，且初始化后值不可再修改（声明的数组、对象还是可变，但**不能重赋值**）

2.也是**块级作用域**。

3.在相同的作用域或块级作用域中，不能使用 const 关键字来重置 var let const关键字声明的变量

## 5.语句特点

### 1.分号可选

在 JavaScript 中，用分号来结束语句是可选的。

### 2.逐行执行

JavaScript 是脚本语言，浏览器会在读取代码时，**逐行地执行**脚本代码。而对于传统编程来说，会在执行前对所有代码进行编译。--------------------------------------------------区别于一般的编程语言直接对**所有代码**编译

故在JS中**字符串不能直接换行**接代码，要用反斜杠   \   来衔接两行

**不完整语句后可换行**------------原理：如果是一个不完整的语句，JS将尝试读取第二行的语句------例：var回车x回车=回车1

某些语句谨慎换行：return------------------------例：return回车1;   ->  return;1;

### 3.注释

//             /*     */

### 4.声明提升

**函数**及**变量**的声明(仅限var)都将被提升到函数的最顶部。变量**可以先使用再声明**。----------x=1;  调用x;  var x;----------调用的x为1

只有声明的变量会提升，**初始化的不会**。------------------调用x;  var x=1;----------调用的x为undefined

## 6.函数

**function**   name   (** ,  ***)
{
    // 执行代码

}-----------------------------------------------不同于其他语言，无论返回值是什么，都写function

### 0.注意

形参不用指定类型，调用时不会检测实参数量，类型----------------故调用时给的实参个数可以随意

### 1.函数存储在变量中

在函数表达式存储在变量后，**变量也可作为一个函数使用**,以上函数实际上是一个 匿名函数 (函数没有名称)。函数存储在变量中，**不需要函数名称**，通常通过变量名来调用。------------可以将变量名当成函数名

var x = function (a, b) {return a * b};
var z = x(4, 3);

### 2.Function()构造函数

var x = new Function("a", "b", "return a * b");
var z = x(4, 3);

### 3.自调用函数

(function () {
    var x = "Hello!!";      // 我将调用自己
})(); 

自调用即指函数声明时就自动调用运行，类似于普通语句块

### 4.函数提升

类似于变量声明提升

### 5.箭头函数（ES6）

(参数1, 参数2, …, 参数N) => { 函数声明 }

1.当参数唯一或函数声明只有一句时 () 或 {} 可以省略

2.箭头函数无函数提升，有的没有自己的this，不适合定义对象方法

### 6.函数可以自带参数(ES6)

function myFunction(x, y = 10) { }

### 7.agruments对象

arguments 对象包含了函数调用的参数数组。

x = f(1, 123, 500, 115, 44, 88);
function f() {var x = arguments[0];}--------------------------通过agruments数组可访问实参，故不写形参也可使用到实参

### 8.通过对象传递参数

在函数内部修改对象的属性就会修改其初始的值。可作用于函数外部（全局变量）

## 7.特殊运算符

1.=(赋值)，==(判等)，**===**(严格判等，值和类型都相等)，!=，**!==**（值和类型至少一个不等）

2.(判断条件) Yes ? No :

## 8.循环共性

1.if,if else,if else if else,switch 和c相同

2.for,while,do while 和c相同-------------------------特殊：对象属性遍历(for(属性in对象){})

3.break,continue 和c相同------------------------------提示：break可用于跳出代码块(labelname:{   })

## 9.类型转换

### 1.typeof，constructor查看数据类型

typeof XX    XX.constructor(返回构造函数)

### 2.类型转换函数

#### 1.String()

#### 2Number()

#### 3.x.toString()  

----------------------------------x=number,boolean,Date

### 4."+"

字符串+数字=字符串

特殊：undefined =+ string----类型为number-------例：var x =+ y;    // x 是一个数字，若y字符串不含数字，则x为NaN

### 4.自动类型转换

输出一个对象或一个变量时 JavaScript 会自动调用变量的 toString() 方法

### 5.转换后数值

转boolean    ture:  string(不为空),  [],   {},   function(){},              false:undefinite,   null,  string(空)--------故"0":true,而0:false

转number   字符串"x":x(x为数字)   "x":NaN(x不为数字)    "":0

​					数组[]:0    [x]:x    [x,y]:NaN    [x]:NaN (x不为数字)

​					null:0        undefined:NaN    {},function(){}:NaN

## 10.正则表达式

/正则表达式主体/修饰符(可选)

是由一个字符序列形成的搜索模式。可用于所有文本**搜索**和文本**替换**的操作。

### 1.字符串对象方法search(),replace()

**参数**可以用**正则表达式或字符串**

正则表达式优势：可使搜索功能更强大

### 2.修饰符

i 	执行对大小写不敏感的匹配。
g 	执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。
m 	执行多行匹配。

### 3.模式

[abc] 	查找方括号之间的任何字符。-----------------------------------   [a-zA-Z0-9]
[0-9] 	查找任何从 0 至 9 的数字。-------------------------------------    \s[1,3]表示匹配1~3个空格。
(x|y) 	查找任何以 | 分隔的选项。 

{}  匹配长度--------------------------------------------------------------------    \s{3} 表示匹配三个空格

\d 	查找数字。                                     \w   数字，字母
\s 	查找空白字符。                              $  结束符---------------------      例：a$以a结束
\b 	匹配单词边界。                              ^  开头(在[]中表示取反)------------------------     例：^a以a开始
\uxxxx 	查找以十六进制数 xxxx 规定的 Unicode 字符。

n+ 	匹配任何包含至少一个 n 的字符串。(1,2········)
n* 	匹配任何包含零个或多个 n 的字符串。(0,1,2·······)
n? 	匹配任何包含零个或一个 n 的字符串。(0,1)

### 4.正则表达式对象(RegExp)方法test(),exec()

参数为字符串

查找该字符串中是否有该正则表达式，test返回boolean类型，exec返回正则表达式

## 11.错误

### 1.try   catch   finally  和java相同

异常类型：err

### 2.throw   异常

异常可以是 字符串、数字、逻辑值或对象。------------------------throw "异常"-------------异常可以自定义一句话

## 12.调试

### 1.console.log() 方法

在调试窗口上打印 JavaScript 值

### 2.debugger 关键字

设置断点

## 13.严格模式       "use strict";

在脚本或函数的开头添加 --------------------函数内声明的只作用于函数内--------------只能在开头

不允许使用未声明的变量

不允许删除变量或对象。不允许删除函数。

不允许变量重名

不允许对只读属性赋值。不允许对一个使用getter方法读取的属性进行赋值

## 14.表单验证

### 1.约束验证DOM方法

#### 1.checkValidity()

检查input中的值是否满足input中的约束条件,返回 boolean

例\<input id="id1" type="number" **min="100" max="300"** **required**>------为checkValidity设置有效范围---required属性自动																																											验证不为空
    if (inpObj**.checkValidity()** == false) {
        document.getElementById("demo").innerHTML = inpObj.validationMessage;
    }



#### 2.setCustomValidity()

设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。



var input信息 = document.getElementById("input的id");

**input信息.setCustomValidity("自定义信息")**;

document.getElementById("demo").innerHTML = **input信息.validationMessage**;



注意：使用 setCustomValidity 设置了自定义提示后，checkValidity 总是会返回 false。

解决方法：1.取消input中的约束条件    setCustomValidity('') /setCustomValidity(null) /setCustomValidity(undefined)

2.input中不写约束条件



### 2.约束验证DOM属性

#### 1.validationMessage 

浏览器错误提示信息,这个信息来自于input的约束条件或setCustomValidate()

#### 2.willValidate 	

指定 input 是否需要验证

#### 3.validity 	

布尔属性值，返回 input 输入值是否合法

##### validity属性的属性

rangeOverflow 	 如果元素的值大于设置的最大值返回ture。 																					rangeUnderflow 	如果元素的值小于它的最小值返回ture。																							tooLong 如果元素的值超过了 maxLength 属性设置的长度返回ture。																	 typeMismatch 	如果元素的值不是预期相匹配的类型返回ture。

例：if (document.getElementById("id1")**.validity.rangeOverflow**) {
       txt = "输入的值太大了";
    }

## 15.this

1.如果单独使用，this 表示全局对象。

2.在对象的定义中（包括在对象方法中），this表示该对象

3.函数(不在对象定义中)中使用 this: \[object Window](一般)      undefined(严格)

4.事件中：接收事件的html元素

### 5.**函数的对象方法apply,call**：

1.var person1 = {
  fullName: function() {-----------------------------------将fullName值设为函数
    return this.firstName + " " + this.lastName;
  }
}
var person2 = {
  firstName:"John",
  lastName: "Doe",
}
person1.fullName.call(person2);--------------调用fullName函数的call对象方法，使函数中的this指向person2

2.function myFunction(a, b) {
    return a * b;
}
myObject = myFunction.call(myObject, 10, 2);     // 返回 20--------第一个参数指定函数this指向，后面的参数指定函数实参

3.apply类似于call,只是多个参数合为一个数组myObject = myFunction.call(myObject,[10,2]);     // 返回 20

## 16.JSON

JSON 是一种轻量级的数据交换格式。
JSON是独立的语言

### 1.格式：

{"sites":[--------------------------------------------------"sites":[ ]表示对象属性为数组
    {"name":"XX", "url":"XX"}, 
    {"name":"XX", "url":"XX"},
    {"name":"XX", "url":"XX"}
]}

### 2.JSON字符串转JS对象---JSON.parse()

var text = '{"sites":[\
    {"name":"XX", "url":"XX"},\
    {"name":"XX", "url":"XX"},\
    {"name":"XX", "url":"XX"} \
]}';
    
var obj = **JSON.parse**(text);-----------------------------此时obj为对象，JSON中的sites变成了对象属性
document.getElementById("demo").innerHTML = obj.sites[1].name + " " + obj.sites[1].url;

### 3.JS对象或数组转JSON字符串-JSON.stringify()

## 17.void

(javascript:)  void(语句)

代表不返回任何值，但是括号内的表达式还是要运行

特别：href="#"与href="javascript:void(0)"的区别

// 阻止链接跳转，URL不会有任何变化
\<a href="javascript:void(0)" rel="nofollow ugc">点击此处\</a>

// 虽然阻止了链接跳转，但URL尾部会多个#(?)，改变了当前URL。（# 主要用于配合 location.hash）
\<a href="#(?)" rel="nofollow ugc">点击此处\</a>

## 18.异步编程

同步按你的代码顺序执行，异步不按照代码顺序执行

**主线程**作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。			常常用**子线程**来完成一些可能消耗时间足够长以至于被用户察觉的事情

### 1.回调函数

1.setTimeout(function () {   }, 3000);--------setTimeout使函数三秒后才执行，此时函数放在子线程，不影响主线程执行

2.应用于异步AJAX

### 2.promise

## 19.代码规范

1.命名规则：    变量和函数为小驼峰法标识, 即除第一个单词之外，其他单词首字母大写（ lowerCamelCase）全局变量为大写常量 (如 PI) 为大写 

2.每行代码字符小于 80

3.运算符 ( = + - * / ) 前后需要添加空格

4.通常使用 4 个空格符号来缩进代码块

5.使用简洁的格式载入 JavaScript 文件 ( type 属性不是必须的):

\<script src="myscript.js">

6.html,css可以用 - 来连接名称，但JS不允许，一般用 _ 

## 20.闭包

var add = (function () {
    var counter = 0;--------------------------------------------------------------初始执行一次
    return function () {return counter += 1;}--------------------------------每次调用add()执行一次
})();

包含了自调用,函数的嵌套,**使得函数拥有私有变量**变成可能,计数器受匿名函数的作用域保护,只能通过 add 方法修改。

function自运行一遍之后,其实最后赋值给add的是return counter += 1 这段代码。
所以后面每次调用add() 其实都是在调用return counter += 1。
闭包会使**父方法的局部变量并且不会随父方法销毁而销毁**, 所以这个counter其实就是来自于第一次function执行时创建的变量。

## 21.类

### 1.类的定义

#### (1)一般

class ClassName {
  **constructor(X,X)** { ... }--------------------构造方法constructor(要写形参)
  method_1() { ... }---------------------**不能加function**（对象方法）
  method_2() { ... }
  method_3() { ... }
}

#### (2)类表达式

let classname1 = class (classname2）{  -----------------类名可选
  constructor(name, url) {
    this.name = name;
    this.url = url;
  }
};
console.log(classname1.name);
// 输出: "classname2"   (classname1)--------类匿名时输出变量名

#### (3)注意

类的定义中自动为strict模式

### 2.使用类

let 对象名=new classname(XX,XX);

#### 类无提升：

使用类必须先声明再使用

### 3.类继承

#### 法(1)ES6 类继承

class A **extends** B{
constructor(name, age) {
    **super(name)**;---------------------------用于引用父类的构造方法中的name
    this.age = age;
}

#### 法(2)原型链继承

利用prototype

### 4.Getter,Setter

**get**   s_name()   {
    return this.sitename;
}
**set **   s_name(x)   {
    this.sitename = x;
}

#### 注意：

使用set,get时不调用对象方法，语法和未设置get,set一样

get:  let x = 对象名.sitename;         set:对象名.sitename=name1;

### 5.static静态方法（类方法）

static f () { }      或        static f (x) { }  

静态方法不能在对象上调用，只能在类中调用。

对象可以作为参数传递给静态方法。

## 22.DOM (文档对象模型)

### 1.查找 HTML 元素

#### (1)通过 id 查找 HTML 元素

var x=**document.getElementById**("intro"); 

#### (2)通过标签名找到 HTML 元素

var y=document.**getElementsByTagName**("p");   (如果有多个p则可以通过数组方式访问y[0])

var x=document.getElementById("main");
var y=x.getElementsByTagName("p");-------------访问id=main的Tag下的Tag\<p>

扩展：getElementsByTagName返回 **HTMLCollection 对象**，类似一个数组，实际不是，可用数组方式访问y[0]，可调用y.length方法。**NodeList 对象**和它相似，区别为HTMLCollection 是 HTML 元素的集合，NodeList 是一个文档节点的集合。所有浏览器的 childNodes 属性，大部分浏览器的 querySelectorAll() 返回 NodeList 对象。

#### (3)通过类名找到 HTML 元素

var x=document.**getElementsByClassName**("intro");

### 2.改变html

document.write()      .innerHTML         .元素属性

### 3.改变css

document.getElementById(id)**.style.css属性**=**"**新样式**"**----------例：.style.color="red";

### 4.事件监听     

#### addEventListener()  

element.addEventListener(event, function, useCapture);
第一个参数是事件的类型 (如 "click" 或 "mousedown").------------------------------------**注意：不加  on**
第二个参数是事件触发后调用的函数。
第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。

1.新加的事件不会覆盖已存在的事件(包括元素原有的事件和监听加的事件)

2.其中的element可以是一般html元素，也可以是文档，window

3.**传参方法**

element.addEventListener("click", function(){ myFunction(p1, p2); });--------用**匿名函数调用带参函数**-------直接用带参函数会无视事件直接执行函数

4.冒泡，捕获

在冒泡中，内部元素的事件会先被触发，然后再触发外部元素。在捕获中，外部元素的事件会先被触发，然后才会触发内部元素的事件

#### removeEventListener()

移除由 addEventListener() 方法添加的事件句柄

#### 跨浏览器解决方法:

​	var x = document.getElementById("myBtn");
if (x.addEventListener) {           --------------------- 所有主流浏览器，除了 IE 8 及更早版本
   x.addEventListener("click", myFunction);
} else if (x.attachEvent) {          ---------------------- IE 8 及更早版本
   x.attachEvent("onclick", myFunction);
}

### 5.创建/移除/替换元素

#### 1.y.appendChild(x)    在父元素y内添加新元素x到尾部

创建 \<p> 元素:   var x = **document.createElement**("p");

创建一个新的文本节点：  var m = **document.createTextNode**("这是一个新的段落。");

将文本节点添加到 \<p> 元素中：   x**.appendChild**(m);

添加到已存在的元素中:    document.getElementById("div1")  **.appendChild**(x);

#### 2.y.insertBefore(x,z)   在父元素y内添加新元素到z前

创建新元素x

添加到已存在的元素中:   document.getElementById("div1")  **.insertBefore**(x,document.getElementById("p1"))

#### 3.y.removeChild(x)     在父元素y中移除x元素

若不知父元素，可用  **.parentNode**  查找

var child = document.getElementById("p1");
child.parentNode.removeChild(child);

#### 4.y.replaceChild(x,z)     在父元素y中z替换为x

创建新元素x

### 6.Cookie

Cookie 以名/值对形式存储

#### 1.创建Cookie

document.cookie="username=John Doe; (expires=Thu, 18 Dec 2043 12:00:00 GMT; )(path=;)"-----过期时间，路径

#### 2.读取Cookie

var x = document.cookie;-----将以字符串的方式返回，但实际cookie并不是字符串

#### 3.修改Cookie

和创建相同

#### 4.删除Cookie

document.cookie = "username=; expires=Thu, 01  Jan 1970 00:00:00 GMT"-----将过期时间设置为已过期的事件

例子：

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<head>
<script>
function setCookie(cname,cvalue,exdays){
	var d = new Date();
	d.setTime(d.getTime()+(exdays*24*60*60*1000));
	var expires = "expires="+d.toGMTString();
	document.cookie = cname+"="+cvalue+"; "+expires;
}
function getCookie(cname){
	var name = cname + "=";
	var ca = document.cookie.split(';');
	for(var i=0; i<ca.length; i++) {
		var c = ca[i].trim();
		if (c.indexOf(name)==0) { return c.substring(name.length,c.length); }
	}
	return "";
}
function checkCookie(){
	var user=getCookie("username");
	if (user!=""){
		alert("欢迎 " + user + " 再次访问");
	}
	else {
		user = prompt("请输入你的名字:","");
  		if (user!="" && user!=null){
    		setCookie("username",user,30);
    	}
	}
}
</script>
</head>
    <body onload="checkCookie()"><p>点击</p></body>
</html>



## 23.BOM   (浏览器对象模型)

所有 JavaScript     全局对象、  全局函数(方法)以及   全局变量(属性)均自动成为 window 对象的成员。document也是window的一个属性

### 1.window

#### 1.innerWidth,innerHeight     浏览器高、宽度

var w=window.innerWidth ------------------Internet Explorer、Chrome、Firefox、Opera 以及 Safari
|| document.documentElement.clientWidth ------------ Internet Explorer 8、7、6、5
|| document.body.clientWidth;

#### 2.window方法

window.open() - 打开新窗口
window.close() - 关闭当前窗口
window.moveTo() - 移动当前窗口
window.resizeTo() - 调整当前窗口的尺寸

### 2.(window.)   screen

screen.availWidth - 可用的屏幕宽度
screen.availHeight - 可用的屏幕高度

### 3.(window.)   location

location.hostname 返回 web 主机的域名
location.pathname 返回当前页面的路径和文件名
location.port 返回 web 主机的端口 （80 或 443）
location.protocol 返回所使用的 web 协议（http: 或 https:）
location.href 属性返回当前页面的 URL。
location.assign("url")    加载新的url,      **可后退**
location.replace("url")  替换为新的url，**不可后退**

### 4.(window.)  history

history.back() - 与在浏览器点击后退按钮相同
history.forward() - 与在浏览器中点击向前按钮相同
history.go(x) 实现向前，后退的功能。-------x<0后退  x>0前进  x=0刷新

### 5.(window.)  navigator

浏览器代号: navigator.appCodeName
浏览器名称: navigator.appName
浏览器版本: navigator.appVersion
启用Cookies: navigator.cookieEnabled
硬件平台: navigator.platform
用户代理: navigator.userAgent
用户代理语言: navigator.language

注意：来自 navigator的信息具有**误导性**，不应该被用于检测浏览器版本，因为数据可被浏览器使用者更改，且一些浏览器会识别错误

### 6弹窗

"sometext"用\n来换行

#### 1.(window.)alert("sometext")

警告弹窗

#### 2.(window.)confirm("sometext")

确认弹窗，出现“确定”和”取消“，返回boolean

#### 3.(window.)prompt("sometext","defaultvalue")

提示弹窗，出现输入窗，提示信息为"sometext"，预设输入信息为"defaultvalue"，返回输入信息

### 7.计时事件

#### 1.(window.)setInterval("javascript function",milliseconds)

**每**milliseconds毫秒调用一次"javascript function"

#### 2.window.setTimeout("javascript function", milliseconds)

milliseconds毫秒**后**调用一次"javascript function"

#### 3.停止计时事件

var x=setInterval(f,ms);     /     var x=setTimeout(f,ms);

**clearInterval(x)**;    /     **clearTimeout(x)**;

## 24.库(框架)

### 1.jQuery

### 2.Prototype

### 3.MooTools

## 25.方法

### 1.数组.indexOf(x)

该方法将**从头到尾地检索数组**，看它是否含有对应的x,如果找到一个，则返回第一次出现的位置,没找到指定元素则返回 -1。

### 2.字符串.split(x)

该方法将字符串按字符串x拆分，并返回拆分后的新字符串（原字符串不改变）

# 备注：

1.form会跳转网页

2.避坑var

3.没有int的自动变整数

4.不要用标志符命名

5.当html文档头部包含有“文档类型声明”时，需要用document.documentElement.scrollTop获得正确的值，而document.body.scrollTop的值为0    
当html文档头部不包含有“文档类型声明”时，可以用document.body.scrolltop来获得值。 

# (四)项目创建

## 1.尝试搭建blog

## (1)nodejs下载

官网下载nodejs

配置路径：node.js\   node.js\node_global

npm install hexo-cli -g # 全局安装hexo命令行工具

hexo init "你的博客目录名称" 

cd "博客目录"

npm install # 安装的依赖项在package.json文件的dependencies字段中可以看到

tree -L 1    -----不管用

## (2)git下载

官网下载git

配置路径：Git\cmd

### <u>*项目云传github的cmd指令</u>

*cd "博客目录"
*git init
***git add .**                           -------选中该目录下所有文件
*git commit -m "my blog first commit"
*git remote add origin "远端github仓库地址.git"
git branch -M main
*git push -u origin main------一直出现各种错误，百度了很久也解决不了，后面突然又行了，git config --global --unset http.proxy    git config --global --unset https.proxy

## (3)github注册及摸索

1.建库 Start a new repository

2.文件修改  进入文件，右上角笔的图像是修改，后commit changes

3.改变目录 左上角手动输入目录

4.删除文件  右上角三点，下拉delete

5.文件上传file hidden解决   如果上传的文件是 . 开头的则会出现hidden问题，最简单的是改名后上传再改回来

## (4)netlify

(弯路：这个网站的注册吐了，邮箱一注册到一半就显示什么账户可疑已被停用，换了三个邮箱全被停用，它的验证是什么驾驶证，护照，身份证，但我都还没注册完就被封了，它和什么验证？况且它是美国网站，我想应该这些证件中国的不行，煎熬了好几个小时，一直邮箱验证，最后斗胆尝试把大陆身份证上传，啊，直接行了)

删除site：site configuration->general->danger zone

## 2.项目初探索

最后发现hexo好像不符合要求，里面的样式是拿.md写的，也看不懂，便尝试换路了

开始尝试直接把我写的.html直接搞到netlify里部署，发现网页直接404

然后百度到web三大主流框架vue,angular,bootstrap并选择了学习vue,在菜鸟教程找到了vue3教程开始学习

### <u>*netlify部署github项目必要条件：</u>

三个必要文件（必须放置在最外层）

index.html
package.json       ----------------注意json中修改"name"为github库名，"dependencies", "devDependencies"的版本也要注意
vite.config.js

(这是我一个个删文件、试错得到的，终于也是解决了老是有时候vue生成的项目有的可以在netlify部署，有的一直报错)

# （五）HTML5

## 1.localStorage 和 sessionStorage 

### 1.localStorage

用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。

保存数据：localStorage.setItem(key,value);
读取数据：localStorage.getItem(key);
删除单个数据：localStorage.removeItem(key);
删除所有数据：localStorage.clear();
得到某个索引的key：localStorage.key(index);

### 2.sessionStorage

针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。

# （六）VUE

## 1.安装vue的npm方法

### 1.

升级 npm
cnpm install npm -g

升级或安装 cnpm-------------------------------------cnpm下载更快
npm install cnpm -g

### 2.安装vue

(**弯路**:开始尝试用  npm init vue@latest ，按教程勾选一堆选项后但是一直报错，创建不了新项目，cmd中用vue指令也全部报错，经过搜索，查找node.js 的安装目录，查看一级目录下没有存在 vue.cmd 指令，确信完全没安装上vue，后最终找到另外的npm安装指令)

**npm install -g vue**

会安装并执行 create-vue

**npm install -g @vue/cli**   -------------安装脚手架vue -cli

查看是否成功

npm list vue -g   -----------查看vue版本

vue –V   ----------------查看脚手架版本

## 2.创建项目

### 1.npm init vue@latest

### 2.vue ui  图形化界面

vue ui 进入后创建项目即可

(弯路：第一次我创建时也是直接报错一页的WARN，我突然想起前面安装脚手架vue -cli的时候也是有几个WARN,于是我立马觉得是脚手架没安装上，查了资料说是npm版本过低，我就npm i -g npm(更新npm)，npm cache clean --force(清除缓存)，npm install -g @vue/cli，结果并不管用，然后又有的说是没有配置路径，我又AppData\Roaming\npm配置了个路径，但没用，然后又有的说是用npm网速不足导致的，换成cnpm下载，果然vue -cli没报WARN了，当我回到vue ui时发现还是WARN,并没解决，后把报错逐句搜索，终于是发现有人说是cmd没以**管理员身份**打开导致的，然后才发现的确如此）

### 3.vite

实现闪电般的冷服务器启动,可以使用 Vite 快速构建 Vue 项目

npm init vite-app    project-name

cd  project-name

cnpm install

cnpm run dev

打开 http://localhost:3000/

### 4.vue create 命令

vue create (options)    app-name

npm run serve  -----启动应用

打开 http://localhost:8080/

## 3.打包

cnpm run build

执行完成后，会在 Vue 项目下会生成一个 dist 目录，该目录一般包含 index.html 文件及 \_assets 目录，_assets 目录包含了静态文件 js、css 以及图片目录 images（如果有图片的话）

修改dist下html中的绝对路径为相对路径

src="/\_assets/index.47c36baf.js"   ->    src="_assets/index.47c36baf.js"

href="/\_assets/style.0637ccc5.css"  ->   href="_assets/style.0637ccc5.css"

## 4.目录结构

build 	项目构建(webpack)相关代码
config 	配置目录，包括端口号等。初学可以使用默认的。
node_modules 	npm 加载的项目依赖模块
src 	这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：
    assets: 放置一些图片，如logo等。
    components: 目录里面放了一个组件文件，可以不用。
    App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。
    main.js: 项目的核心文件。
    index.css: 样式文件。
static 	静态资源目录，如图片、字体等。
public 	公共资源目录。
test 	初始测试目录，可删除
.xxxx文件 	这些是一些配置文件，包括语法配置，git配置等。
index.html 	首页入口文件，你可以添加一些 meta 信息或统计代码啥的。
package.json 	项目配置文件。
README.md 	项目的说明文档，markdown 格式
dist 	使用 npm run build 命令打包后会生成该目录。

 **修改src/APP.vue 文件**

\<HelloWorld msg="随意内容" />

## 5.起步

先在 HTML 页面中引入 Vue 的 JS 文件：

\<script src="https://unpkg.com/vue@next">\</script>

\<div id="name2" class="demo">
  {{ name3 }}                                 -----------------------{{    }}:用于输出对象属性和函数返回值
\</div>

\<script>
const name1 = {                               -------------------------<u>vueapp</u>(name1)的设置
  data() {
    return {
      name3: '输出内容'
    }
  }
}

Vue.createApp(name1).mount('#name2')---------------------**Vue.creatApp()**:    创建<u>vueapp</u>(name1)
\</script>                                                                             <u>vueapp</u>**.mount('#id')**:    将<u>vueapp</u>挂载到id的html元素中

注：可合并两步(创建并附初始属性)

const name1 = Vue.createApp({

data(){return {------------------------data选项
value1:XX
}}

methods:{-----------------------------方法
f1(){}
}

})

const vm = app.mount('#name2')

### 函数表示法：

法1.methods:{
	f1(){},
	f2(){}
}
法2.methods:{
	f1:function (){},
	f2:function (){}
}

## 6.vue指令

v-bind 	用于将 Vue 实例的数据绑定到 HTML 元素的属性上。
v-if 	用于根据表达式的值来条件性地渲染元素或组件。
v-show 	v-show 是 Vue.js 提供的一种指令，用于根据表达式的值来条件性地显示或隐藏元素。
v-for 	用于根据数组或对象的属性值来循环渲染元素或组件。
v-on 	用于在 HTML 元素上绑定事件监听器，使其能够触发 Vue 实例中的方法或函数。
v-model 用于在表单控件和 Vue 实例的数据之间创建双向数据绑定。

### 1.v-model

v-model 用于在**表单控件**和 **Vue 实例的数据**之间创建**双向数据绑定**。

***\<input*** type="text" ***v-model="message">***\</input>

\<p>{{ message }}\</p>

将input中的输入与message双向绑定，输入的值实时改变massage值

### 2.v-bind(:)

v-bind 	用于将 Vue 实例的数据绑定到 HTML 元素的属性上。（单向输出）

1.\<img :src="imageSrc">-------------单向输出
data() {return {imageSrc: 'XX.png'}}
将data中的imageSrc的值取出到v-bind后的imageSrc中

2.(1)\<div :class="{ 'classname1':dataname1, 'classname2':dataname2 }">\</div>----**多项选择**，依据dataname1,2对应布尔的值

(2).\<div :class="classObject">\</div>----**多项选择**（*通过对象的方法*）
data() {return { classObject: { 'dataname1': false, 'dataname2': true }}

(3).\<div class="class1" :class="[dataname1, dataname2]">\</div>-----**多项并选**（*通过数组的方法*）
等同于\<div class="class1 datavalue1 datavalue2">\</div>

(4).\<div class="class1" :class="[dataname0 ? dataname1 : ' ', dataname2]">\</div>--4变体，判断后选择是否选入

3.(1)\<div :style="{ color: dataname1, fontSize: dataname2 + 'px' }">\</div>-----**内联样式设置style**----dataname1可换为[dataname1,dataname2]

(2)\<div :style="styleObject">\</div>------(*通过对象的方法*)-----styleObject可换为[styleObject1, styleObject2]
data() { return {styleObject: {color: "red",fontSize: "30px"}}}



### 3.v-on(@)

v-on 	用于在 HTML 元素上绑定事件监听器，使其能够触发 Vue 实例中的方法或函数。--可缩写：v-on:click->@click

@click和onclick区别：@click可用于修改app中data的值，触发app中 的方法

### 4.v-show

v-show 	v-show 是 Vue.js 提供的一种指令，用于根据表达式的值来条件性地显示或隐藏元素。

***\<button v-on:click="***showMessage = !showMessage***">***显示/隐藏\</button>-------每次点击将showMessage值致反
***\<p v-show="showMessage">***Hello Vue!\</p>------------------------***v-show值为ture时显示元素，否则不显示***
data() {return {showMessage: true}}

### 5.v-if v-else v-else-if

v-if 	用于根据表达式的值来条件性地渲染元素或组件。

***\<p v-if="showMessage">***Hello Vue!\</p>----------------***v-if值为true则插入元素，否则不插入***
***\<p v-else>***Goodbye Vue!\</p>

data() {return {showMessage: true}}

注意：v-if和v-show效果看似类似，实际上v-if决定是否插入，v-show决定是否显示

### 6.v-for

v-for 	用于根据数组或对象的属性值来循环渲染元素或组件。

#### (1).迭代对象

\<li v-for="***(item,index) in name1***" >---------------------------------------name1为***对象数组***，index可选
      {{ item.text }}
\</li>
data() {return {
      name1: [
        { text: 'Item 1' },
        { text: 'Item 2' },
        { text: 'Item 3' }
      ]
}}

#### (2).迭代对象属性

\<li v-for="***(value, key, index) in name1***">{{ index }}. {{ key }} : {{ value }}\</li>-----------name1为***一个对象***，key和index可选
data() {return {
      name1: {
        name: '    ',
        url: '     ',
        slogan: '      '
      }}}

#### (3).迭代整数

\<li v-for="***name1 in 10***">{{name1}}\</li>--------------------------------------------------name1***未定义***，会***从1递加迭代***10次

#### (4).可对数组元素进行处理

\<li v-for="***name1 in f1***">{{ name1 }}\</li>------------------------------------------------name1***未定义***，只会***迭代显示f1返回值***
data() {
        return { ***numbers***: [  ,  ,  ,  ] }
    },
 computed: {
        f1() {return this.numbers.filter(number => number % 2 === 0)}-----该函数返回用filter()选择的***numbers***中为偶数的数
    }



## 7.模板语法

### 1.输出数据：{{ }}

***{{...}}*** 标签的内容将会被替代为对应组件实例中message属性的值，如果message属性的值发生了改变，{{...}} 标签内容也会更新。(可以通过使用 **v-once** 指令执行一次性地插值\<span v-once>这个将不会改变: {{ message }}\</span>)

### 2.输出html代码：v-html

***\<span v-html="rawHtml">***我会被覆盖\</span>--------------v-html**会覆盖原来的html元素**
data() {return {***rawHtml: '\<span style="color: red">这里会显示红色！\</span>'***}}

### 3.输出html元素的属性值：v-bind

一般：
\<div v-bind:id="dynamicId">\</div>

进阶：根据use的值选择是否输出元素属性值
\<style>
.class1{  }
\</style>
\<div v-bind:class="{'class1': use}">\</div>
data() {return {use: false}}

### 4.表达式支持

注意：vue语句只支持js表达式(运算式、"."访问js对象属性和方法)，不支持语句、控制流（var x=1/if(){}）

{{5+5}}    {{ ok ? 'YES' : 'NO' }}    {{ message.split('').reverse().join('') }}

### 5.指令、属性、修饰符

\<form v-on:submit.prevent="onSubmit">\</form>
          指令:属性.修饰符

## 8.组件  component      

组件：\<name1>\</name1>    最终会被替换成template定义的html语句（\<name1>将不存在）

### 1.局部组件

var My-Component-Name = {<u>***template***</u>: '\<h1>自定义组件!\</h1>'}-------------------template：模版 
const app1 = Vue.**createApp**({<u>***components***</u>: {'my-component-name': My-Component-Name}})
app1.mount('#id1')
id1下使用\<my-component-name>\</my-component-name>

### 2.全局组件

const app1 = Vue.**createApp**({ data(){} f(){} })
app1.<u>***component***</u>(  'my-component-name'   ,   {***<u>template</u>***: '\<h1>自定义组件!\</h1>' }  )
app1.mount('#id1')
id1下使用\<my-component-name>\</my-component-name>

### 3.prop选项

props: ['数据变量名']

是子组件用来**接受父组件**传递过来的**数据**的一个自定义属性。

和template放的位置相同，用上面的全局组件举例就是将my-component-name的数据传给\<h1>，即传给template定义的html元素

流程：

const app = Vue.**createApp**( {data() {return {sites: [{ id: 1, t: 'Google' },{ id: 2, t: 'Runoob' }]}}})
app.**component**('site-info', { <u>props</u>: ['id','t'],   <u>template</u>: \<h4>{{ id }} - {{ t }}\</h4>})
app.**mount**('#app')
\<site-info v-for="site in sites" :id="site.id" :t="site.t">\</site-info>

### 4.prop验证

可以为 props 中的值提供一个带有验证需求的对象，替代原来的字符串数组，验证失败时控制台警告

prop:{数据名：检查方法，数据名：检查方法，}

检查方法：

1.基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)

Number

2.多个可能的类型

[String, Number]

3.必填的字符串

{type: String,required: true}

4.带有默认值的数字

{type: Number,default: 100}

5.带有默认值的对象

{type: Object,default: function () {return { message: 'hello' }}}-----------------对象或数组默认值必须从一个工厂函数获取

6.自定义验证函数

{validator: function (value) {.....;return true/false;}}}}--------------要验证的数通过value传入函数进行验证

### 5.组件使用class属性

1.template中仅一对html元素

const app = Vue.createApp({})
app.component('name1', {template: '\<**h1 class="classA classB**">\</h1>'})
app.mount('#app')
\<**name1 class="classC classD"**>\</name1>

最终name1被替换后classABCD都保留（仅限template中只有一对html元素）

2.template中有多对html元素，需要定义哪些html对接收(使用**:class="$attrs.class**)

const app = Vue.createApp({})
app.component('name1', {template: \`\<p **:class="$attrs.class**">\</p>\<span>\</span> \`})-----注意是**反引号`**
app.mount('#app')
\<name1 class="classA">\</name1>

## 9.计算属性    computed

const app = {
  data() {return {message:...}},
  ***computed:*** { 
    reversedMessage: function () {----------------- 函数作为计算属性的 getter
      return this.message.split('').reverse().join('')---`this` 指向 vm 实例
    }
  }
}
Vue.createApp(app).mount('#app')
{{ reversedMessage }}

注：message值改变时reversedMessage值也会改变

与method区别：**效果上两个都是一样**的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。

{{ message0 }}
{{ message1***()*** }}
computed: {
    message0: 
	function () {
     	 return this.message.split('').reverse().join('')
    }
  },
methods: {
    message1: 
	function () {
     	 return this.message.split('').reverse().join('')
    }
  }

### 可选setter

computed: {
    message0: ***{***-------多个{
      get: function () {-----------------------getter(将app中data的值输出到{{message0}},相当于间接输出,直接输出为:{{name}})
        return this.name + ' ' + this.url
      },
      set: function (newValue) {---------------setter（修改app中data的值）
        var names = newValue.split(' ')
        this.name = names[0]
        this.url = names[names.length - 1]
      }
    ***}***
  }

vm.message0 = '·········';------------------------调用setter的方法

## 10.监听属性  watched

用于监听app内data的变化并做出响应

法1：**watch :** {-----------------监听data中的数据变化，数据变化自动调用相应函数
    dataname1 (newValue, oldValue) { },-----------函数名必须与data中的数据名相同
    dataname2 (){}                                              (newXX,oldXX可直接获取变化前后的值)
}

法2：vm = Vue.createApp(app).mount('#app')
vm.**$watch**('dataname1', function (newValue, oldValue) { })

## 11.事件处理