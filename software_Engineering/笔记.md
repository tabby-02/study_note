# 一.概述

## 1.软件的概念和特点

1.**软件=程序+数据+文档**

2.特点

➢软件是开发的或者是工程化的，而不是制造的
➢软件生产是简单拷贝，而不是重复开发
➢软件产品易于多次修改，且总是要求修改
➢软件开发的环境对产品影响较大
➢软件开发的时间和工作量难以估计
➢软件开发进度难以客观衡量
➢软件的测试非常困难
➢软件不会磨损和老化，但会退化
➢软件维护不是简单更换元器件，变更容易产生新的问题

3.双重作用

**一方面是一种产品,另一方面是开发其他软件产品的工具**

4.软件开发的发展

**个体化**，**作坊式**，**工程化**，**产业化**

5.为什么软件发展如此之快？

**计算需求**，**业务需求**，**嵌入需求**，**架构需求**

## 2.软件危机

1.概念：在计算机软件的开发和维护过程中所遇到的一系列严重问题。

2.**产生软件危机的原因**

客观：软件本身特点，主观：不正确的开发方法

3.**消除软件危机的途径：软件工程**

## 3.软件工程

1.定义

（1）应用系统化的、学科化的、定量的方法，来开发、运行和维护软件，即，将工程应用到软件。（2）对（1）中各种方法的研究

2.**软件工程三要素：方法、工具、过程**

3.**软件工程的发展已经历了四个重要阶段**

传统的软件工程，对象工程，过程工程，构件工程

4.**软件工程的7个原则**

使用阶段性生命周期计划的管理，
进行连续的验证，
保证严格的产品控制，
使用现代编程工具工程实践，
保持清晰的责任分配，
用更好更少的人，
保持过程改进

# 二.软件过程

## 1.软件过程的概念

### 1.软件生命周期

1.软件生命周期概念：软件产品或软件系统从**设计、投入使用到被淘汰**的全过程

2.问题定义，可行性研究，需求分析，总体设计，详细设计，编码，测试，维护

### 2.软件过程

2.软件过程的概念：软件过程是在工作产品构建过程中，所需完成的**活动**、**动作**和**任务**的集合。

### 3.软件过程评估

CMM（**能力成熟度模型**），**ISO 9000**（质量标准体系），**ISO/IEC 15504 SPICE**（信息技术软件过程评估）

## 2.软件过程模型

### 1.瀑布模型*

软件开发过程与软件生命周期一致，也称经典生命周期模型，是一种以文档为驱动的模型，是线性模型，阶段间具有顺序性和依赖性，是推迟实现的观点

**缺点**：**增加工作量**，**早期错误发现晚**，**开发风险大**，**不适应需求变化**

**适用**：系统**需求明确**且稳定、技术成熟、工程管理较严格的场合，如军工、航天、医疗。

### 2.V模型？

**瀑布模型的变种**

### 3.原型模型？

<u>原型</u>：一个<u>部分开发</u>的产品

**优点**：减少**需求不明**确带来的风险

**缺点**：构造原型采用的技术和工具不一定主流，快速建立起来的系统加上连续的修改可能导致原型质量低下，设计者在质量和原型中进行折中，客户意识不到一些**质量问题**

适用：客户不清楚系统的具体输入输出；或开发者不确定算法的效率、软件与操作系统是否兼容以及客户与计算机交互的方式。

### 4.增量模型*

<u>增量</u>：满足用户需求的一个<u>子集</u>，能够完成一定功能、<u>小而可用</u>的软件

结合了<u>原型模型</u>的基本要素和<u>迭代</u>的特征，每个增量的开发<u>可用瀑布或快速原型模型</u>，并行

优点： 软件能够**更早投入市场**； 

适用：适用于软件开发中**需求可能发生变化**、具有较大风险、或者希望**尽早进入市场**的项目。

### 5.螺旋模型？

把**开发活动和风险管理结合**起来控制风险

优点：原型的进化贯穿整个软件生存周期，这将有助于目标软件的适应能力，支持用户**需求的动态变化**

缺点：如果每次迭代的效率不高，致使迭代次数过多，**将会增加成本并推迟交付时间**；需要有相当丰富的风险评估经验和专门知识，**要求开发队伍水平较高**

适用：适用于**需求不明确**或者需求可能发生变化的**大型复杂**的软件系统。

### 6.喷泉模型？

喷泉模型是一种以用户需求为动力，以**对象**为驱动的模型，主要用于描述面向对象的软件开发过程

优点：喷泉模型的各个阶段没有明显的界限，开发人员可以**同步进行开发**，可以提高软件项目开发效率，**节省开发时间**，适应于面向对象的软件开发过程

适用：适用于**面向对象**开发

### 7.基于构件的开发模型*

优点：软件**复用**思想；降低开发成本和风险，加快开发进度，提高软件质量

适用：系统之间有**共性**的情况

### 8.统一过程模型？

基于面向对象方法学，迭代式开发，基于构件体系结构，

### 9.敏捷开发模型*

是**基本原理**和**开发准则**的结合，小但有激情的团队

适用：适用于需求模糊且经常改变的场合，适合**商业竞争环境**下的项目。

### 10.模型选择

瀑布模型：前期需求明确

原型模型：用户无系统使用经验，需求分析人员技能不足

增量模型：需求不稳定，尽早进入市场，资金和成本无法一次到位

敏捷开发模型：商业竞争，小团队（经验少时不使用）

# 三.项目管理

## 1.项目管理概念

1.定义：计划、协调、度量、监控、控制及报告等**管理方法在软件开发和维护中的具体应用**，以保证整个过程是系统的、有原则的、可量化的

2.4P要素：**人员**，**产品**，**过程**，**项目**（people,product,process,project）

## 2.软件度量

1.度量目的：持续改进软件过程，并用于项目估算、质量控制、生产率评估等

2.软件项目度量的方法
▪ 面向规模的度量
▪ 面向功能点的度量
▪ 面向对象的度量
▪ 面向用例的度量

### 1.面向规模的度量

▪ 千行代码（ KLOC ）： 这些代码指的是源代码，通过源代码的行数来直观度量一个软件程序有多大规模
▪ **生产率**（PM）：PM = **L / E**, L表示**代码总量**(单位：KLOC)，E表示软件**工作量**(单位：**人月**) 
▪ 每千行代码的平均成本（ CKL ）：CKL = S / L，S为软件项目总开销 ， L表示代码总量(单位：KLOC)
▪ 代码出错率（EQRl）：EQRl = Ne / L，Ne表示代码出错的行数，L表示代码总量(单位：KLOC)
▪ 文档与代码比（Dl）：Dl = Pd / L，Pd表示文档页数， L表示代码总量(单位：KLOC)

<img src="笔记图片\Snipaste_2023-12-30_14-29-40.png" style="zoom:100%;" /> 

### 2.面向功能点的度量

▪ FP = UFC×TCF = UFC × (0.65 + 0.01×累加Fi)
▪ **UFC** (Unadjusted Function Component) : **未调整功能点计数**, **5个信息量的“加权和”**
▪ TCF (Technical Complexity Factor): 技术复杂度因子
▪ Fi: 14个因素的“复杂性调节值” (i =1..14)
▪ 0.65, 0.01都是经验常数，现在由国际组织根据大量项目跟踪分析获得。

1.UFC计算

▪外部输入EI数×加权因子(简单=3,平均=4,复杂=6)
▪外部输出EO数×加权因子(简单=4,平均=5,复杂=7)
▪外部查询EQ数×加权因子(简单=3,平均=4,复杂=6)
▪内部逻辑文件ILF数×加权因子(简单=7,平均=10,复杂=15)
▪外部接口EIF数×加权因子(简单=5,平均=7,复杂=10)
UFC ＝ 上述计算值的总和（加权和）

## 3.软件项目估算

方法：基于**分解**技术的项目估算方法 ，基于**经验**的项目估算方法

### 1.基于**分解**技术的项目估算方法

三点期望值法：估计期望值=(最大值＋4×最可能值＋最小值) / 6

### 2.基于**经验**的项目估算方法

## 4.项目进度计划

项目进度计划的可视化：甘特图<img src="笔记图片\Snipaste_2023-12-30_15-04-09.png" style="zoom:50%;" />

里程碑显示项目进展中的重大工作完成

## 5.WBS分解，任务网络图

### 1.WBS(工作分解结构)

**工作分解结构**（Work Breakdown Structure, **WBS**）是将项目按照功能或过程进行**逐层分解**，直到划分为若干内容单一、便于组织管理的单项工作，最终形成的**树形**结构示意图

<img src="笔记图片\Snipaste_2023-12-30_15-11-17.png" style="zoom:80%;" /> 

### 2.任务网络图

**任务网络图**是项目所有任务（活动）及其之间**逻辑关系**（依赖关系）的一个图解表示，并**从左到右**来表示项目的**时间顺序**。

任务网络图是一个有向权重网络图，一般用节点表示事件，弧表示任务（活动） ，弧上的权值表示任务（活动）耗费的时间

<img src="笔记图片\Snipaste_2023-12-30_15-13-36.png" style="zoom:50%;" /> 

#### 关键路径

在任务网络图中，从项目开始到项目完成有许多条路径，路径上所有**弧权重之和最大**的路径（路径最长）叫关键路径

▪ 关键路径上任何任务（活动）的延长都会导致整个项目周期的延长
▪ 如果想缩短项目周期，就必须缩短关键路径的长度

# 四.图

## 1.数据流图

<img src="笔记图片\Snipaste_2023-12-30_15-47-05.png" style="zoom:50%;" /> 

<img src="笔记图片\Snipaste_2023-12-30_15-51-25.png" style="zoom:50%;" /> 

## 2.用例图*

<img src="笔记图片\Snipaste_2023-12-30_15-57-40.png" style="zoom:50%;" /> <img src="笔记图片\Snipaste_2023-12-30_16-00-50.png" style="zoom:50%;" />

• 在扩展关系中，一个基本用例执行时，可以执行、也可以不执行扩展用例部分
• 在包含关系中，在执行基本用例时，一定会执行包含用例部分

 注意：用例格式：**动宾**
			用例**只写与系统有关**的，不写与系统无关的，故先找到系统

## 3.类图*

<img src="笔记图片\Snipaste_2023-12-30_16-16-17.png" style="zoom:80%;" /> <img src="笔记图片\Snipaste_2023-12-30_16-21-23.png" style="zoom:80%;" />

<img src="笔记图片\Snipaste_2023-12-30_16-29-15.png" style="zoom:100%;" /> 

• **边界类**是系统内部与系统外部的业务主角之间进行**交互**建模的类（窗口，界面，面板）

## 4.顺序图*

<img src="笔记图片\Snipaste_2023-12-30_16-59-06.png" style="zoom:80%;" /> <img src="笔记图片\Snipaste_2023-12-30_17-03-29.png" style="zoom:80%;" />



## 5.协作图*

<img src="笔记图片\Snipaste_2023-12-30_17-15-34.png" style="zoom:100%;" /> 

## 6.活动图*

<img src="笔记图片\Snipaste_2023-12-30_17-24-00.png" style="zoom:50%;" /> <img src="笔记图片\Snipaste_2023-12-30_17-24-14.png" style="zoom:50%;" />

<img src="笔记图片\Snipaste_2023-12-30_17-28-14.png" style="zoom:100%;" />

## 7.流程图

<img src="笔记图片\Snipaste_2023-12-30_17-19-51.png" style="zoom:80%;" /> 

## 8.状态图

<img src="笔记图片\Snipaste_2023-12-30_17-35-43.png" style="zoom:50%;" /> 

## 9.组件图

组件，接口，关系

<img src="笔记图片\Snipaste_2023-12-30_17-39-19.png" style="zoom:50%;" /> <img src="笔记图片\Snipaste_2023-12-30_17-39-14.png" style="zoom:80%;" />

# 五.黑白盒测试

## 1.白盒测试

### 1.逻辑覆盖

**语句覆盖**：就是设计若干个测试用例，运行被测程序，使得**每一可执行语句**至少执行一次

**分支覆盖**：就是设计若干个测试用例，运行被测程序，使得程序中**每个**判断的取真**分支**和取假分支至少经历一次。分支覆盖又称为判定覆盖

**条件覆盖**：设计若干个测试用例，运行被测程序，使得程序中**每个判断**的**每个条件**的可能取值至少执行一次

**条件组合覆盖**：设计足够的测试用例，运行被测程序，使得每个判断的所有可能的**条件**取值**组合**至少执行一次

### 2.控制流图覆盖测试

1.**节点覆盖**，**边覆盖**

2.**路径覆盖**

3.**基本路径覆盖**

独立路径：从控制流图来看，一条独立路径是**至少包含**有一条在其它独立路径中**从未有过**的边的路径。

## 2.黑盒测试

**等价类**：某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的**错误都是等效的**。

### 等价类划分

（一）确定等价类
（二）建立等价类表，列出所有划分出的等价类
（三）为每一个等价类规定一个唯一**编号**；
（四）设计一个新的测试用例，**尽可能多**地覆盖尚未被覆盖的**有效**等价类，重复这一步，直到所有的有效等价类都被覆盖为止；
（五）设计一个新的测试用例，**仅覆盖一个**尚未被覆盖的**无效**等价类，重复这一步，直到所
有的无效等价类都被覆盖为止

### 边界值分析

例：如输入分数范围为[60,75），则成绩等级为及格，采用边界值分析法设计测试用例。
上点：为60和75
内点：即60到75之间的任何一点，如：67。
离点：为59和74。
测试用例为{59，60，67，74，75}

# 六.质量保证

## 1.软件质量保证

**软件质量**：明确表示是否符合功能和性能要求，明确地记载开发标准和所有专业开发软件的期望的隐性特点

**软件质量保证**(SQA)：遵照一定的软件生产标准、过程和步骤对软件质量进行评估的活动。

## 2.软件测试策略

定义:软件测试策略为软件开发人员、质量保证组织、和客户提供了一个路线图规定了测试的主要步骤

软件测试策略V模型：
单元测试
集成测试
系统测试
验收测试

## 3.软件测试方法:

白盒测试
黑盒测试
灰盒测试

# 七.需求分析

## 1.需求分析的概念

确定系统必须具有的功能和性能，系统要求的运行环境，并且预测系统发展的前景

## 2.需求的类型

**功能性需求**:描述系统应该做什么，即为用户和其它系统完成的功能、提供的服务

**非功能需求**:必须遵循的标准，外部界面的细节，实现的约束条件，质量属性等等

## 3.需求分析过程

需求获取,需求提炼,需求描述,需求验证

需求变更

## 4.需求获取

### 1.需求获取概念

►软件需求的来源
►软件工程师收集这些软件需求的方法。



### 2.需求获取技术

▪ －采访(客户)
▪ －设定情景（用例）
▪ －原型
▪ －会议
▪ －观察商业过程和工作流

▪ －现有软件
▪ －用户扮演
▪ －头脑风暴

### 3.需求获取面临的挑战

挑战:

1.客户**说不清楚**需求
2.需求**易变性**
3.问题的**复杂性**和对问题空间**理解的不完备性**与不一致性

解决:

1）尽可能地分析清楚**哪些是稳定的需求，哪些是易变的需求**。以便在进行系统设计时，将软件的核心建筑在稳定的需求上，否则将会吃尽苦头。
2） 在**合同**中一定要说清楚“做什么”和“不做什么”。

## 5.需求提炼

定义:对应用问题及环境的理解和分析，为问题涉及的信息、功能及系统行为建立模型。将用户需求精确化、完全化，最终形成下一步的需求规格说明书

•需求提炼（需求分析）的核心在于建立分析模型。

• 需求提炼（需求分析）采用多种形式描述需求，通过建立需求的多种视图，揭示出一些更深的问题。

• 需求提炼（需求分析）还包括与客户的交流以澄清某些易混淆的问题，并明确哪些需求更为重要，其目的是确保所有风险承担者尽早地对项目达成共识并对将来的产品有个相同而清晰的认识

## 6.需求描述:需求规格说明书

定义:需求规格说明书是对待开发系统的行为的完整描述。它包含了功能性需求和非功能性需求。

需求分析工作完成的一个基本标志是形成了一份完整的、规范的需求规格说明书。

## 7.需求验证

### 1.重要性

需求验证的重要性：如果在后续的开发或当系统投入使用时才发现需求文档中的错误，就会导致更大代价的返工。

### 2.需求验证的工作

有效性检查
一致性检查
完备性检查
现实性检查

# 八.软件设计

## 1.软件设计定义

软件设计定义为软件系统或组件的架构、构件、接口和其他特性的定义过程及该过程的结果。

## 2.设计技术

数据设计
架构设计
部署设计
接口设计
组件设计

## 3.面向对象设计原则

• 开闭原则:对外延具有开放性，对修改具有封闭性
• Liskov替换原则:从基类导出的类传递给组件时，使用基类的组件应该仍然能够正确完成其功能(java多态)
• 依赖倒置原则:依赖于抽象，而非具体实现
• 接口分离原则:多个客户专用接口比一个通用接口好
• 发布复用等价性原则:以包为单位，将可复用的类分组打包成能管理和控制的包并作为一个更新的版本，而非对每个类分别进行升级
• 共同封装原则:应该将易变的类放在同一个包里，将变化隔离出来
• 共同复用原则:根据内聚性进行分组，只有那些一起被复用的类才应该包含在一个包中

## 4.面向对象设计的活动

**系统架构设计**
**用例设计**
**类设计**
数据库设计
用户界面设计

### 1.架构设计

步骤:
构造系统的物理模型
设计子系统
非功能需求设计

#### 设计子系统

步骤:
按照软件层次划分子系统，软件层次通常可划分为用户界面层、专用软件层、通用软件层、中间层和数据层
定义子系统之间的关系：
定义子系统的接口

### 2.用例设计

### 3.类设计